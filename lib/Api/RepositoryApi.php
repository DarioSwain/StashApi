<?php
/**
 * RepositoryApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Stash API
 *
 * REST-ish endpoint for interacting with Stash
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use \Swagger\Client\ApiClient;
use \Swagger\Client\ApiException;
use \Swagger\Client\Configuration;
use \Swagger\Client\ObjectSerializer;

/**
 * RepositoryApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class RepositoryApi
{
    /**
     * API Client
     *
     * @var \Swagger\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \Swagger\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\Swagger\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \Swagger\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \Swagger\Client\ApiClient $apiClient set the API client
     *
     * @return RepositoryApi
     */
    public function setApiClient(\Swagger\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation createRepository
     *
     * createRepository
     *
     * @param object $dynamic  (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function createRepository($dynamic, $project_key)
    {
        list($response) = $this->createRepositoryWithHttpInfo($dynamic, $project_key);
        return $response;
    }

    /**
     * Operation createRepositoryWithHttpInfo
     *
     * createRepository
     *
     * @param object $dynamic  (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRepositoryWithHttpInfo($dynamic, $project_key)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling createRepository');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling createRepository');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createRepositoryCommitComment
     *
     * createRepositoryCommitComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id  (required)
     * @param string $since  (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function createRepositoryCommitComment($dynamic, $project_key, $repository_slug, $commit_id, $since = null)
    {
        list($response) = $this->createRepositoryCommitCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $commit_id, $since);
        return $response;
    }

    /**
     * Operation createRepositoryCommitCommentWithHttpInfo
     *
     * createRepositoryCommitComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id  (required)
     * @param string $since  (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createRepositoryCommitCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $commit_id, $since = null)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling createRepositoryCommitComment');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling createRepositoryCommitComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling createRepositoryCommitComment');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling createRepositoryCommitComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteRepository
     *
     * deleteRepository
     *
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function deleteRepository($repository_slug, $project_key)
    {
        list($response) = $this->deleteRepositoryWithHttpInfo($repository_slug, $project_key);
        return $response;
    }

    /**
     * Operation deleteRepositoryWithHttpInfo
     *
     * deleteRepository
     *
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRepositoryWithHttpInfo($repository_slug, $project_key)
    {
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling deleteRepository');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling deleteRepository');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deleteRepositoryCommitComment
     *
     * deleteRepositoryCommitComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @param int $comment_id the ID of the comment to retrieve (required)
     * @param int $version The expected version of the comment. This must match the server&#39;s version of the comment or                   the delete will fail. To determine the current version of the comment, the comment should be                   fetched from the server prior to the delete. Look for the &#39;version&#39; attribute in the returned                   JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function deleteRepositoryCommitComment($project_key, $repository_slug, $commit_id, $comment_id, $version = null)
    {
        list($response) = $this->deleteRepositoryCommitCommentWithHttpInfo($project_key, $repository_slug, $commit_id, $comment_id, $version);
        return $response;
    }

    /**
     * Operation deleteRepositoryCommitCommentWithHttpInfo
     *
     * deleteRepositoryCommitComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @param int $comment_id the ID of the comment to retrieve (required)
     * @param int $version The expected version of the comment. This must match the server&#39;s version of the comment or                   the delete will fail. To determine the current version of the comment, the comment should be                   fetched from the server prior to the delete. Look for the &#39;version&#39; attribute in the returned                   JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteRepositoryCommitCommentWithHttpInfo($project_key, $repository_slug, $commit_id, $comment_id, $version = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling deleteRepositoryCommitComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling deleteRepositoryCommitComment');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling deleteRepositoryCommitComment');
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $comment_id when calling deleteRepositoryCommitComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($version !== null) {
            $queryParams['version'] = $this->apiClient->getSerializer()->toQueryValue($version);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                "{" . "commentId" . "}",
                $this->apiClient->getSerializer()->toPathValue($comment_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation disableRepositoryHook
     *
     * disableRepositoryHook
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function disableRepositoryHook($project_key, $repository_slug, $hook_key)
    {
        list($response) = $this->disableRepositoryHookWithHttpInfo($project_key, $repository_slug, $hook_key);
        return $response;
    }

    /**
     * Operation disableRepositoryHookWithHttpInfo
     *
     * disableRepositoryHook
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function disableRepositoryHookWithHttpInfo($project_key, $repository_slug, $hook_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling disableRepositoryHook');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling disableRepositoryHook');
        }
        // verify the required parameter 'hook_key' is set
        if ($hook_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $hook_key when calling disableRepositoryHook');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($hook_key !== null) {
            $resourcePath = str_replace(
                "{" . "hookKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($hook_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation enableRepositoryHook
     *
     * enableRepositoryHook
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @param int $content_length  (optional, default to 0)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function enableRepositoryHook($project_key, $repository_slug, $hook_key, $content_length = null)
    {
        list($response) = $this->enableRepositoryHookWithHttpInfo($project_key, $repository_slug, $hook_key, $content_length);
        return $response;
    }

    /**
     * Operation enableRepositoryHookWithHttpInfo
     *
     * enableRepositoryHook
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @param int $content_length  (optional, default to 0)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function enableRepositoryHookWithHttpInfo($project_key, $repository_slug, $hook_key, $content_length = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling enableRepositoryHook');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling enableRepositoryHook');
        }
        // verify the required parameter 'hook_key' is set
        if ($hook_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $hook_key when calling enableRepositoryHook');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // header params
        if ($content_length !== null) {
            $headerParams['Content-Length'] = $this->apiClient->getSerializer()->toHeaderValue($content_length);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($hook_key !== null) {
            $resourcePath = str_replace(
                "{" . "hookKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($hook_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation forkRepository
     *
     * forkRepository
     *
     * @param object $dynamic  (required)
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function forkRepository($dynamic, $repository_slug, $project_key)
    {
        list($response) = $this->forkRepositoryWithHttpInfo($dynamic, $repository_slug, $project_key);
        return $response;
    }

    /**
     * Operation forkRepositoryWithHttpInfo
     *
     * forkRepository
     *
     * @param object $dynamic  (required)
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function forkRepositoryWithHttpInfo($dynamic, $repository_slug, $project_key)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling forkRepository');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling forkRepository');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling forkRepository');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getForkedRepositories
     *
     * getForkedRepositories
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getForkedRepositories($project_key, $repository_slug)
    {
        list($response) = $this->getForkedRepositoriesWithHttpInfo($project_key, $repository_slug);
        return $response;
    }

    /**
     * Operation getForkedRepositoriesWithHttpInfo
     *
     * getForkedRepositories
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getForkedRepositoriesWithHttpInfo($project_key, $repository_slug)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getForkedRepositories');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getForkedRepositories');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/forks";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/forks'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRelatedRepositories
     *
     * getRelatedRepositories
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRelatedRepositories($project_key, $repository_slug)
    {
        list($response) = $this->getRelatedRepositoriesWithHttpInfo($project_key, $repository_slug);
        return $response;
    }

    /**
     * Operation getRelatedRepositoriesWithHttpInfo
     *
     * getRelatedRepositories
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRelatedRepositoriesWithHttpInfo($project_key, $repository_slug)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRelatedRepositories');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRelatedRepositories');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/related";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/related'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositories
     *
     * getRepositories
     *
     * @param string $name (optional) if specified, this will limit the resulting repository list to ones whose name                     matches this parameter&#39;s value. The match will be done case-insensitive and any leading                     and/or trailing whitespace characters on the &lt;code&gt;name&lt;/code&gt; parameter will be stripped. (optional)
     * @param string $projectname (optional) if specified, this will limit the resulting repository list to ones whose project&#39;s                     name matches this parameter&#39;s value. The match will be done case-insensitive and any leading                     and/or trailing whitespace characters on the &lt;code&gt;projectname&lt;/code&gt; parameter will                     be stripped. (optional)
     * @param string $permission (optional) if specified, it must be a valid repository permission level name and will limit                     the resulting repository list to ones that the requesting user has the specified permission                     level to. If not specified, the default implicit &#39;read&#39; permission level will be assumed. The                     currently supported explicit permission values are &lt;tt&gt;REPO_READ&lt;/tt&gt;, &lt;tt&gt;REPO_WRITE&lt;/tt&gt;                     and &lt;tt&gt;REPO_ADMIN&lt;/tt&gt;. (optional)
     * @param string $visibility (optional) if specified, this will limit the resulting repository list based on the                     repositories visibility. Valid values are &lt;em&gt;public&lt;/em&gt; or &lt;em&gt;private&lt;/em&gt;. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositories($name = null, $projectname = null, $permission = null, $visibility = null)
    {
        list($response) = $this->getRepositoriesWithHttpInfo($name, $projectname, $permission, $visibility);
        return $response;
    }

    /**
     * Operation getRepositoriesWithHttpInfo
     *
     * getRepositories
     *
     * @param string $name (optional) if specified, this will limit the resulting repository list to ones whose name                     matches this parameter&#39;s value. The match will be done case-insensitive and any leading                     and/or trailing whitespace characters on the &lt;code&gt;name&lt;/code&gt; parameter will be stripped. (optional)
     * @param string $projectname (optional) if specified, this will limit the resulting repository list to ones whose project&#39;s                     name matches this parameter&#39;s value. The match will be done case-insensitive and any leading                     and/or trailing whitespace characters on the &lt;code&gt;projectname&lt;/code&gt; parameter will                     be stripped. (optional)
     * @param string $permission (optional) if specified, it must be a valid repository permission level name and will limit                     the resulting repository list to ones that the requesting user has the specified permission                     level to. If not specified, the default implicit &#39;read&#39; permission level will be assumed. The                     currently supported explicit permission values are &lt;tt&gt;REPO_READ&lt;/tt&gt;, &lt;tt&gt;REPO_WRITE&lt;/tt&gt;                     and &lt;tt&gt;REPO_ADMIN&lt;/tt&gt;. (optional)
     * @param string $visibility (optional) if specified, this will limit the resulting repository list based on the                     repositories visibility. Valid values are &lt;em&gt;public&lt;/em&gt; or &lt;em&gt;private&lt;/em&gt;. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoriesWithHttpInfo($name = null, $projectname = null, $permission = null, $visibility = null)
    {
        // parse inputs
        $resourcePath = "/api/1.0/repos";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // query params
        if ($projectname !== null) {
            $queryParams['projectname'] = $this->apiClient->getSerializer()->toQueryValue($projectname);
        }
        // query params
        if ($permission !== null) {
            $queryParams['permission'] = $this->apiClient->getSerializer()->toQueryValue($permission);
        }
        // query params
        if ($visibility !== null) {
            $queryParams['visibility'] = $this->apiClient->getSerializer()->toQueryValue($visibility);
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/repos'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositories1
     *
     * getRepositories
     *
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositories1($project_key)
    {
        list($response) = $this->getRepositories1WithHttpInfo($project_key);
        return $response;
    }

    /**
     * Operation getRepositories1WithHttpInfo
     *
     * getRepositories
     *
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositories1WithHttpInfo($project_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositories1');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepository
     *
     * getRepository
     *
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepository($repository_slug, $project_key)
    {
        list($response) = $this->getRepositoryWithHttpInfo($repository_slug, $project_key);
        return $response;
    }

    /**
     * Operation getRepositoryWithHttpInfo
     *
     * getRepository
     *
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryWithHttpInfo($repository_slug, $project_key)
    {
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepository');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepository');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryBranches
     *
     * getRepositoryBranches
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $base base branch or tag to compare each branch to (for the metadata providers that uses that information) (optional)
     * @param bool $details whether to retrieve plugin-provided metadata about each branch (optional)
     * @param string $filter_text the text to match on (optional)
     * @param string $order_by ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated) (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryBranches($project_key, $repository_slug, $base = null, $details = null, $filter_text = null, $order_by = null)
    {
        list($response) = $this->getRepositoryBranchesWithHttpInfo($project_key, $repository_slug, $base, $details, $filter_text, $order_by);
        return $response;
    }

    /**
     * Operation getRepositoryBranchesWithHttpInfo
     *
     * getRepositoryBranches
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $base base branch or tag to compare each branch to (for the metadata providers that uses that information) (optional)
     * @param bool $details whether to retrieve plugin-provided metadata about each branch (optional)
     * @param string $filter_text the text to match on (optional)
     * @param string $order_by ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated) (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryBranchesWithHttpInfo($project_key, $repository_slug, $base = null, $details = null, $filter_text = null, $order_by = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryBranches');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryBranches');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($base !== null) {
            $queryParams['base'] = $this->apiClient->getSerializer()->toQueryValue($base);
        }
        // query params
        if ($details !== null) {
            $queryParams['details'] = $this->apiClient->getSerializer()->toQueryValue($details);
        }
        // query params
        if ($filter_text !== null) {
            $queryParams['filterText'] = $this->apiClient->getSerializer()->toQueryValue($filter_text);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = $this->apiClient->getSerializer()->toQueryValue($order_by);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryChanges
     *
     * getRepositoryChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $since the commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes.                      If not specified the commit&#39;s first parent is assumed (if one exists) (optional)
     * @param string $until the commit to retrieve changes for (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryChanges($project_key, $repository_slug, $since = null, $until = null)
    {
        list($response) = $this->getRepositoryChangesWithHttpInfo($project_key, $repository_slug, $since, $until);
        return $response;
    }

    /**
     * Operation getRepositoryChangesWithHttpInfo
     *
     * getRepositoryChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $since the commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes.                      If not specified the commit&#39;s first parent is assumed (if one exists) (optional)
     * @param string $until the commit to retrieve changes for (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryChangesWithHttpInfo($project_key, $repository_slug, $since = null, $until = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryChanges');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryChanges');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/changes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = $this->apiClient->getSerializer()->toQueryValue($until);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/changes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommit
     *
     * getRepositoryCommit
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the commit ID to retrieve (required)
     * @param string $path an optional path to filter the commit by. If supplied the details returned &lt;i&gt;may not&lt;/i&gt;              be for the specified commit. Instead, starting from the specified commit, they will be the              details for the first commit affecting the specified path. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryCommit($project_key, $repository_slug, $commit_id, $path = null)
    {
        list($response) = $this->getRepositoryCommitWithHttpInfo($project_key, $repository_slug, $commit_id, $path);
        return $response;
    }

    /**
     * Operation getRepositoryCommitWithHttpInfo
     *
     * getRepositoryCommit
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the commit ID to retrieve (required)
     * @param string $path an optional path to filter the commit by. If supplied the details returned &lt;i&gt;may not&lt;/i&gt;              be for the specified commit. Instead, starting from the specified commit, they will be the              details for the first commit affecting the specified path. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitWithHttpInfo($project_key, $repository_slug, $commit_id, $path = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommit');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommit');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling getRepositoryCommit');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommitChanges
     *
     * getRepositoryCommitChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the commit to retrieve changes for (required)
     * @param string $since the commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes.                      If not specified the commit&#39;s first parent is assumed (if one exists) (optional)
     * @param bool $with_comments {@code true} to apply comment counts in the changes (the default); otherwise, {@code false}                      to stream changes without comment counts (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryCommitChanges($project_key, $repository_slug, $commit_id, $since = null, $with_comments = null)
    {
        list($response) = $this->getRepositoryCommitChangesWithHttpInfo($project_key, $repository_slug, $commit_id, $since, $with_comments);
        return $response;
    }

    /**
     * Operation getRepositoryCommitChangesWithHttpInfo
     *
     * getRepositoryCommitChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the commit to retrieve changes for (required)
     * @param string $since the commit to which &lt;code&gt;until&lt;/code&gt; should be compared to produce a page of changes.                      If not specified the commit&#39;s first parent is assumed (if one exists) (optional)
     * @param bool $with_comments {@code true} to apply comment counts in the changes (the default); otherwise, {@code false}                      to stream changes without comment counts (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitChangesWithHttpInfo($project_key, $repository_slug, $commit_id, $since = null, $with_comments = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommitChanges');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommitChanges');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling getRepositoryCommitChanges');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($with_comments !== null) {
            $queryParams['withComments'] = $this->apiClient->getSerializer()->toQueryValue($with_comments);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommitComment
     *
     * getRepositoryCommitComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @param int $comment_id the ID of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryCommitComment($project_key, $repository_slug, $commit_id, $comment_id)
    {
        list($response) = $this->getRepositoryCommitCommentWithHttpInfo($project_key, $repository_slug, $commit_id, $comment_id);
        return $response;
    }

    /**
     * Operation getRepositoryCommitCommentWithHttpInfo
     *
     * getRepositoryCommitComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @param int $comment_id the ID of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitCommentWithHttpInfo($project_key, $repository_slug, $commit_id, $comment_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommitComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommitComment');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling getRepositoryCommitComment');
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $comment_id when calling getRepositoryCommitComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                "{" . "commentId" . "}",
                $this->apiClient->getSerializer()->toPathValue($comment_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommitComments
     *
     * getRepositoryCommitComments
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id  (required)
     * @param string $path  (optional)
     * @param string $since  (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return object
     */
    public function getRepositoryCommitComments($project_key, $repository_slug, $commit_id, $path = null, $since = null)
    {
        list($response) = $this->getRepositoryCommitCommentsWithHttpInfo($project_key, $repository_slug, $commit_id, $path, $since);
        return $response;
    }

    /**
     * Operation getRepositoryCommitCommentsWithHttpInfo
     *
     * getRepositoryCommitComments
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id  (required)
     * @param string $path  (optional)
     * @param string $since  (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitCommentsWithHttpInfo($project_key, $repository_slug, $commit_id, $path = null, $since = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommitComments');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommitComments');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling getRepositoryCommitComments');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'object',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'object', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'object', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommitDiff
     *
     * getRepositoryCommitDiff
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryCommitDiff($project_key, $repository_slug, $commit_id, $context_lines = null, $since = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        list($response) = $this->getRepositoryCommitDiffWithHttpInfo($project_key, $repository_slug, $commit_id, $context_lines, $since, $src_path, $whitespace, $with_comments);
        return $response;
    }

    /**
     * Operation getRepositoryCommitDiffWithHttpInfo
     *
     * getRepositoryCommitDiff
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitDiffWithHttpInfo($project_key, $repository_slug, $commit_id, $context_lines = null, $since = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommitDiff');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommitDiff');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling getRepositoryCommitDiff');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // query params
        if ($with_comments !== null) {
            $queryParams['withComments'] = $this->apiClient->getSerializer()->toQueryValue($with_comments);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommitDiffByPath
     *
     * getRepositoryCommitDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the path to the file which should be diffed (optional) (required)
     * @param string $commit_id  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryCommitDiffByPath($project_key, $repository_slug, $path, $commit_id, $context_lines = null, $since = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        list($response) = $this->getRepositoryCommitDiffByPathWithHttpInfo($project_key, $repository_slug, $path, $commit_id, $context_lines, $since, $src_path, $whitespace, $with_comments);
        return $response;
    }

    /**
     * Operation getRepositoryCommitDiffByPathWithHttpInfo
     *
     * getRepositoryCommitDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the path to the file which should be diffed (optional) (required)
     * @param string $commit_id  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitDiffByPathWithHttpInfo($project_key, $repository_slug, $path, $commit_id, $context_lines = null, $since = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommitDiffByPath');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommitDiffByPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling getRepositoryCommitDiffByPath');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling getRepositoryCommitDiffByPath');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // query params
        if ($with_comments !== null) {
            $queryParams['withComments'] = $this->apiClient->getSerializer()->toQueryValue($with_comments);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                "{" . "path" . "}",
                $this->apiClient->getSerializer()->toPathValue($path),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryCommits
     *
     * getRepositoryCommits
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path an optional path to filter commits by (optional)
     * @param string $since the commit ID or ref (exclusively) to retrieve commits after (optional)
     * @param string $until the commit ID (SHA1) or ref (inclusively) to retrieve commits before (optional)
     * @param bool $with_counts optionally include the total number of commits and total number of unique authors (optional, default to false)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryCommits($project_key, $repository_slug, $path = null, $since = null, $until = null, $with_counts = null)
    {
        list($response) = $this->getRepositoryCommitsWithHttpInfo($project_key, $repository_slug, $path, $since, $until, $with_counts);
        return $response;
    }

    /**
     * Operation getRepositoryCommitsWithHttpInfo
     *
     * getRepositoryCommits
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path an optional path to filter commits by (optional)
     * @param string $since the commit ID or ref (exclusively) to retrieve commits after (optional)
     * @param string $until the commit ID (SHA1) or ref (inclusively) to retrieve commits before (optional)
     * @param bool $with_counts optionally include the total number of commits and total number of unique authors (optional, default to false)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryCommitsWithHttpInfo($project_key, $repository_slug, $path = null, $since = null, $until = null, $with_counts = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryCommits');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryCommits');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = $this->apiClient->getSerializer()->toQueryValue($until);
        }
        // query params
        if ($with_counts !== null) {
            $queryParams['withCounts'] = $this->apiClient->getSerializer()->toQueryValue($with_counts);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryContent
     *
     * getRepositoryContent
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $at the changeset id or ref to retrieve the content for. (optional)
     * @param bool $type if true only the type will be returned for the file path instead of the contents. (optional, default to false)
     * @param string $blame if present the blame will be returned for the file as well. (optional)
     * @param string $no_content if present and used with blame only the blame is retrieved instead of the contents. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryContent($project_key, $repository_slug, $at = null, $type = null, $blame = null, $no_content = null)
    {
        list($response) = $this->getRepositoryContentWithHttpInfo($project_key, $repository_slug, $at, $type, $blame, $no_content);
        return $response;
    }

    /**
     * Operation getRepositoryContentWithHttpInfo
     *
     * getRepositoryContent
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $at the changeset id or ref to retrieve the content for. (optional)
     * @param bool $type if true only the type will be returned for the file path instead of the contents. (optional, default to false)
     * @param string $blame if present the blame will be returned for the file as well. (optional)
     * @param string $no_content if present and used with blame only the blame is retrieved instead of the contents. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryContentWithHttpInfo($project_key, $repository_slug, $at = null, $type = null, $blame = null, $no_content = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryContent');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryContent');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/browse";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($at !== null) {
            $queryParams['at'] = $this->apiClient->getSerializer()->toQueryValue($at);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = $this->apiClient->getSerializer()->toQueryValue($type);
        }
        // query params
        if ($blame !== null) {
            $queryParams['blame'] = $this->apiClient->getSerializer()->toQueryValue($blame);
        }
        // query params
        if ($no_content !== null) {
            $queryParams['noContent'] = $this->apiClient->getSerializer()->toQueryValue($no_content);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/browse'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryContentByPath
     *
     * getRepositoryContentByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the file path to retrieve content from (required)
     * @param string $at the changeset id or ref to retrieve the content for. (optional)
     * @param bool $type if true only the type will be returned for the file path instead of the contents. (optional, default to false)
     * @param string $blame if present the blame will be returned for the file as well. (optional)
     * @param string $no_content if present and used with blame only the blame is retrieved instead of the contents. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryContentByPath($project_key, $repository_slug, $path, $at = null, $type = null, $blame = null, $no_content = null)
    {
        list($response) = $this->getRepositoryContentByPathWithHttpInfo($project_key, $repository_slug, $path, $at, $type, $blame, $no_content);
        return $response;
    }

    /**
     * Operation getRepositoryContentByPathWithHttpInfo
     *
     * getRepositoryContentByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the file path to retrieve content from (required)
     * @param string $at the changeset id or ref to retrieve the content for. (optional)
     * @param bool $type if true only the type will be returned for the file path instead of the contents. (optional, default to false)
     * @param string $blame if present the blame will be returned for the file as well. (optional)
     * @param string $no_content if present and used with blame only the blame is retrieved instead of the contents. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryContentByPathWithHttpInfo($project_key, $repository_slug, $path, $at = null, $type = null, $blame = null, $no_content = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryContentByPath');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryContentByPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling getRepositoryContentByPath');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/browse/{path}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($at !== null) {
            $queryParams['at'] = $this->apiClient->getSerializer()->toQueryValue($at);
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = $this->apiClient->getSerializer()->toQueryValue($type);
        }
        // query params
        if ($blame !== null) {
            $queryParams['blame'] = $this->apiClient->getSerializer()->toQueryValue($blame);
        }
        // query params
        if ($no_content !== null) {
            $queryParams['noContent'] = $this->apiClient->getSerializer()->toQueryValue($no_content);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                "{" . "path" . "}",
                $this->apiClient->getSerializer()->toPathValue($path),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/browse/{path}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryDefaultBranch
     *
     * getRepositoryDefaultBranch
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryDefaultBranch($project_key, $repository_slug)
    {
        list($response) = $this->getRepositoryDefaultBranchWithHttpInfo($project_key, $repository_slug);
        return $response;
    }

    /**
     * Operation getRepositoryDefaultBranchWithHttpInfo
     *
     * getRepositoryDefaultBranch
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryDefaultBranchWithHttpInfo($project_key, $repository_slug)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryDefaultBranch');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryDefaultBranch');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches/default";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches/default'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryGroupsWithAnyPermission
     *
     * getRepositoryGroupsWithAnyPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryGroupsWithAnyPermission($project_key, $repository_slug, $filter = null)
    {
        list($response) = $this->getRepositoryGroupsWithAnyPermissionWithHttpInfo($project_key, $repository_slug, $filter);
        return $response;
    }

    /**
     * Operation getRepositoryGroupsWithAnyPermissionWithHttpInfo
     *
     * getRepositoryGroupsWithAnyPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryGroupsWithAnyPermissionWithHttpInfo($project_key, $repository_slug, $filter = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryGroupsWithAnyPermission');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryGroupsWithAnyPermission');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryGroupsWithoutAnyPermission
     *
     * getRepositoryGroupsWithoutAnyPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryGroupsWithoutAnyPermission($project_key, $repository_slug, $filter = null)
    {
        list($response) = $this->getRepositoryGroupsWithoutAnyPermissionWithHttpInfo($project_key, $repository_slug, $filter);
        return $response;
    }

    /**
     * Operation getRepositoryGroupsWithoutAnyPermissionWithHttpInfo
     *
     * getRepositoryGroupsWithoutAnyPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryGroupsWithoutAnyPermissionWithHttpInfo($project_key, $repository_slug, $filter = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryGroupsWithoutAnyPermission');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryGroupsWithoutAnyPermission');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups/none";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups/none'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryHook
     *
     * getRepositoryHook
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryHook($project_key, $repository_slug, $hook_key)
    {
        list($response) = $this->getRepositoryHookWithHttpInfo($project_key, $repository_slug, $hook_key);
        return $response;
    }

    /**
     * Operation getRepositoryHookWithHttpInfo
     *
     * getRepositoryHook
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryHookWithHttpInfo($project_key, $repository_slug, $hook_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryHook');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryHook');
        }
        // verify the required parameter 'hook_key' is set
        if ($hook_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $hook_key when calling getRepositoryHook');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($hook_key !== null) {
            $resourcePath = str_replace(
                "{" . "hookKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($hook_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryHookSettings
     *
     * getRepositoryHookSettings
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryHookSettings($project_key, $repository_slug, $hook_key)
    {
        list($response) = $this->getRepositoryHookSettingsWithHttpInfo($project_key, $repository_slug, $hook_key);
        return $response;
    }

    /**
     * Operation getRepositoryHookSettingsWithHttpInfo
     *
     * getRepositoryHookSettings
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryHookSettingsWithHttpInfo($project_key, $repository_slug, $hook_key)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryHookSettings');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryHookSettings');
        }
        // verify the required parameter 'hook_key' is set
        if ($hook_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $hook_key when calling getRepositoryHookSettings');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($hook_key !== null) {
            $resourcePath = str_replace(
                "{" . "hookKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($hook_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryHooks
     *
     * getRepositoryHooks
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $type the optional type to filter by. Valid values are &lt;code&gt;PRE_RECEIVE&lt;/code&gt; or &lt;code&gt;POST_RECEIVE&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryHooks($project_key, $repository_slug, $type = null)
    {
        list($response) = $this->getRepositoryHooksWithHttpInfo($project_key, $repository_slug, $type);
        return $response;
    }

    /**
     * Operation getRepositoryHooksWithHttpInfo
     *
     * getRepositoryHooks
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $type the optional type to filter by. Valid values are &lt;code&gt;PRE_RECEIVE&lt;/code&gt; or &lt;code&gt;POST_RECEIVE&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryHooksWithHttpInfo($project_key, $repository_slug, $type = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryHooks');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryHooks');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($type !== null) {
            $queryParams['type'] = $this->apiClient->getSerializer()->toQueryValue($type);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryTags
     *
     * getRepositoryTags
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter_text the text to match on (optional)
     * @param string $order_by ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated) (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryTags($project_key, $repository_slug, $filter_text = null, $order_by = null)
    {
        list($response) = $this->getRepositoryTagsWithHttpInfo($project_key, $repository_slug, $filter_text, $order_by);
        return $response;
    }

    /**
     * Operation getRepositoryTagsWithHttpInfo
     *
     * getRepositoryTags
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter_text the text to match on (optional)
     * @param string $order_by ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last updated) (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryTagsWithHttpInfo($project_key, $repository_slug, $filter_text = null, $order_by = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryTags');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryTags');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/tags";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($filter_text !== null) {
            $queryParams['filterText'] = $this->apiClient->getSerializer()->toQueryValue($filter_text);
        }
        // query params
        if ($order_by !== null) {
            $queryParams['orderBy'] = $this->apiClient->getSerializer()->toQueryValue($order_by);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/tags'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryUsersWithAnyPermission
     *
     * getRepositoryUsersWithAnyPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryUsersWithAnyPermission($project_key, $repository_slug, $filter = null)
    {
        list($response) = $this->getRepositoryUsersWithAnyPermissionWithHttpInfo($project_key, $repository_slug, $filter);
        return $response;
    }

    /**
     * Operation getRepositoryUsersWithAnyPermissionWithHttpInfo
     *
     * getRepositoryUsersWithAnyPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryUsersWithAnyPermissionWithHttpInfo($project_key, $repository_slug, $filter = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryUsersWithAnyPermission');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryUsersWithAnyPermission');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getRepositoryUsersWithoutPermission
     *
     * getRepositoryUsersWithoutPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getRepositoryUsersWithoutPermission($project_key, $repository_slug, $filter = null)
    {
        list($response) = $this->getRepositoryUsersWithoutPermissionWithHttpInfo($project_key, $repository_slug, $filter);
        return $response;
    }

    /**
     * Operation getRepositoryUsersWithoutPermissionWithHttpInfo
     *
     * getRepositoryUsersWithoutPermission
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $filter if specified only group names containing the supplied string will be returned (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getRepositoryUsersWithoutPermissionWithHttpInfo($project_key, $repository_slug, $filter = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getRepositoryUsersWithoutPermission');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getRepositoryUsersWithoutPermission');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users/none";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($filter !== null) {
            $queryParams['filter'] = $this->apiClient->getSerializer()->toQueryValue($filter);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users/none'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listRepositoryFiles
     *
     * listRepositoryFiles
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $at the changeset id or ref (e.g. a branch or tag) to list the files at.              If not specified the default branch will be used instead. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function listRepositoryFiles($project_key, $repository_slug, $at = null)
    {
        list($response) = $this->listRepositoryFilesWithHttpInfo($project_key, $repository_slug, $at);
        return $response;
    }

    /**
     * Operation listRepositoryFilesWithHttpInfo
     *
     * listRepositoryFiles
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $at the changeset id or ref (e.g. a branch or tag) to list the files at.              If not specified the default branch will be used instead. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRepositoryFilesWithHttpInfo($project_key, $repository_slug, $at = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling listRepositoryFiles');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling listRepositoryFiles');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/files";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($at !== null) {
            $queryParams['at'] = $this->apiClient->getSerializer()->toQueryValue($at);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/files'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listRepositoryFilesByPath
     *
     * listRepositoryFilesByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the directory to list files for. (required)
     * @param string $at the changeset id or ref (e.g. a branch or tag) to list the files at.              If not specified the default branch will be used instead. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function listRepositoryFilesByPath($project_key, $repository_slug, $path, $at = null)
    {
        list($response) = $this->listRepositoryFilesByPathWithHttpInfo($project_key, $repository_slug, $path, $at);
        return $response;
    }

    /**
     * Operation listRepositoryFilesByPathWithHttpInfo
     *
     * listRepositoryFilesByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the directory to list files for. (required)
     * @param string $at the changeset id or ref (e.g. a branch or tag) to list the files at.              If not specified the default branch will be used instead. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function listRepositoryFilesByPathWithHttpInfo($project_key, $repository_slug, $path, $at = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling listRepositoryFilesByPath');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling listRepositoryFilesByPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling listRepositoryFilesByPath');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/files/{path}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($at !== null) {
            $queryParams['at'] = $this->apiClient->getSerializer()->toQueryValue($at);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                "{" . "path" . "}",
                $this->apiClient->getSerializer()->toPathValue($path),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/files/{path}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation repositoryCompareChanges
     *
     * repositoryCompareChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $from the source changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $to the target changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $from_repo an optional parameter specifying the source repository containing the source changeset                  if that changeset is not present in the current repository; the repository can be specified                  by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by                  a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function repositoryCompareChanges($project_key, $repository_slug, $from = null, $to = null, $from_repo = null)
    {
        list($response) = $this->repositoryCompareChangesWithHttpInfo($project_key, $repository_slug, $from, $to, $from_repo);
        return $response;
    }

    /**
     * Operation repositoryCompareChangesWithHttpInfo
     *
     * repositoryCompareChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $from the source changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $to the target changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $from_repo an optional parameter specifying the source repository containing the source changeset                  if that changeset is not present in the current repository; the repository can be specified                  by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by                  a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryCompareChangesWithHttpInfo($project_key, $repository_slug, $from = null, $to = null, $from_repo = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling repositoryCompareChanges');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling repositoryCompareChanges');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/changes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($from !== null) {
            $queryParams['from'] = $this->apiClient->getSerializer()->toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = $this->apiClient->getSerializer()->toQueryValue($to);
        }
        // query params
        if ($from_repo !== null) {
            $queryParams['fromRepo'] = $this->apiClient->getSerializer()->toQueryValue($from_repo);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/changes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation repositoryCompareCommits
     *
     * repositoryCompareCommits
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $from the source changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $to the target changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $from_repo an optional parameter specifying the source repository containing the source changeset                  if that changeset is not present in the current repository; the repository can be specified                  by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by                  a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function repositoryCompareCommits($project_key, $repository_slug, $from = null, $to = null, $from_repo = null)
    {
        list($response) = $this->repositoryCompareCommitsWithHttpInfo($project_key, $repository_slug, $from, $to, $from_repo);
        return $response;
    }

    /**
     * Operation repositoryCompareCommitsWithHttpInfo
     *
     * repositoryCompareCommits
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $from the source changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $to the target changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $from_repo an optional parameter specifying the source repository containing the source changeset                  if that changeset is not present in the current repository; the repository can be specified                  by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by                  a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryCompareCommitsWithHttpInfo($project_key, $repository_slug, $from = null, $to = null, $from_repo = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling repositoryCompareCommits');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling repositoryCompareCommits');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/commits";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($from !== null) {
            $queryParams['from'] = $this->apiClient->getSerializer()->toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = $this->apiClient->getSerializer()->toQueryValue($to);
        }
        // query params
        if ($from_repo !== null) {
            $queryParams['fromRepo'] = $this->apiClient->getSerializer()->toQueryValue($from_repo);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/commits'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation repositoryCompareDiffByPath
     *
     * repositoryCompareDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the path to the file to diff (optional) (required)
     * @param string $from the source changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $to the target changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $from_repo an optional parameter specifying the source repository containing the source changeset                  if that changeset is not present in the current repository; the repository can be specified                  by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by                  a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt; (optional)
     * @param string $src_path  (optional)
     * @param int $context_lines an optional number of context lines to include around each added or removed lines in the diff (optional, default to -1)
     * @param string $whitespace an optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function repositoryCompareDiffByPath($project_key, $repository_slug, $path, $from = null, $to = null, $from_repo = null, $src_path = null, $context_lines = null, $whitespace = null)
    {
        list($response) = $this->repositoryCompareDiffByPathWithHttpInfo($project_key, $repository_slug, $path, $from, $to, $from_repo, $src_path, $context_lines, $whitespace);
        return $response;
    }

    /**
     * Operation repositoryCompareDiffByPathWithHttpInfo
     *
     * repositoryCompareDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the path to the file to diff (optional) (required)
     * @param string $from the source changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $to the target changeset (can be a partial/full changeset id or qualified/unqualified ref name) (optional)
     * @param string $from_repo an optional parameter specifying the source repository containing the source changeset                  if that changeset is not present in the current repository; the repository can be specified                  by either its ID &lt;em&gt;fromRepo&#x3D;42&lt;/em&gt; or by its project key plus its repo slug separated by                  a slash: &lt;em&gt;fromRepo&#x3D;projectKey/repoSlug&lt;/em&gt; (optional)
     * @param string $src_path  (optional)
     * @param int $context_lines an optional number of context lines to include around each added or removed lines in the diff (optional, default to -1)
     * @param string $whitespace an optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryCompareDiffByPathWithHttpInfo($project_key, $repository_slug, $path, $from = null, $to = null, $from_repo = null, $src_path = null, $context_lines = null, $whitespace = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling repositoryCompareDiffByPath');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling repositoryCompareDiffByPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling repositoryCompareDiffByPath');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/diff/{path}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($from !== null) {
            $queryParams['from'] = $this->apiClient->getSerializer()->toQueryValue($from);
        }
        // query params
        if ($to !== null) {
            $queryParams['to'] = $this->apiClient->getSerializer()->toQueryValue($to);
        }
        // query params
        if ($from_repo !== null) {
            $queryParams['fromRepo'] = $this->apiClient->getSerializer()->toQueryValue($from_repo);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                "{" . "path" . "}",
                $this->apiClient->getSerializer()->toPathValue($path),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/diff/{path}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation repositoryShowDiff
     *
     * repositoryShowDiff
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $until the target revision to diff to (required) (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function repositoryShowDiff($project_key, $repository_slug, $context_lines = null, $since = null, $src_path = null, $until = null, $whitespace = null)
    {
        list($response) = $this->repositoryShowDiffWithHttpInfo($project_key, $repository_slug, $context_lines, $since, $src_path, $until, $whitespace);
        return $response;
    }

    /**
     * Operation repositoryShowDiffWithHttpInfo
     *
     * repositoryShowDiff
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $until the target revision to diff to (required) (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryShowDiffWithHttpInfo($project_key, $repository_slug, $context_lines = null, $since = null, $src_path = null, $until = null, $whitespace = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling repositoryShowDiff');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling repositoryShowDiff');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/diff";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = $this->apiClient->getSerializer()->toQueryValue($until);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/diff'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation repositoryShowDiffByPath
     *
     * repositoryShowDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the path to the file which should be diffed (required) (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $until the target revision to diff to (required) (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function repositoryShowDiffByPath($project_key, $repository_slug, $path, $context_lines = null, $since = null, $src_path = null, $until = null, $whitespace = null)
    {
        list($response) = $this->repositoryShowDiffByPathWithHttpInfo($project_key, $repository_slug, $path, $context_lines, $since, $src_path, $until, $whitespace);
        return $response;
    }

    /**
     * Operation repositoryShowDiffByPathWithHttpInfo
     *
     * repositoryShowDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $path the path to the file which should be diffed (required) (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $since the base revision to diff from. If omitted the parent revision of the until revision is used (optional)
     * @param string $src_path the source path for the file, if it was copied, moved or renamed (optional)
     * @param string $until the target revision to diff to (required) (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function repositoryShowDiffByPathWithHttpInfo($project_key, $repository_slug, $path, $context_lines = null, $since = null, $src_path = null, $until = null, $whitespace = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling repositoryShowDiffByPath');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling repositoryShowDiffByPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling repositoryShowDiffByPath');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/diff/{path}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($since !== null) {
            $queryParams['since'] = $this->apiClient->getSerializer()->toQueryValue($since);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($until !== null) {
            $queryParams['until'] = $this->apiClient->getSerializer()->toQueryValue($until);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                "{" . "path" . "}",
                $this->apiClient->getSerializer()->toPathValue($path),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/diff/{path}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation retryCreateRepository
     *
     * retryCreateRepository
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function retryCreateRepository($project_key, $repository_slug)
    {
        list($response) = $this->retryCreateRepositoryWithHttpInfo($project_key, $repository_slug);
        return $response;
    }

    /**
     * Operation retryCreateRepositoryWithHttpInfo
     *
     * retryCreateRepository
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function retryCreateRepositoryWithHttpInfo($project_key, $repository_slug)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling retryCreateRepository');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling retryCreateRepository');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/recreate";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/recreate'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation revokeRepositoryPermissionsForGroup
     *
     * revokeRepositoryPermissionsForGroup
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $name the name of the group (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function revokeRepositoryPermissionsForGroup($project_key, $repository_slug, $name = null)
    {
        list($response) = $this->revokeRepositoryPermissionsForGroupWithHttpInfo($project_key, $repository_slug, $name);
        return $response;
    }

    /**
     * Operation revokeRepositoryPermissionsForGroupWithHttpInfo
     *
     * revokeRepositoryPermissionsForGroup
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $name the name of the group (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function revokeRepositoryPermissionsForGroupWithHttpInfo($project_key, $repository_slug, $name = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling revokeRepositoryPermissionsForGroup');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling revokeRepositoryPermissionsForGroup');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation revokeRepositoryPermissionsForUser
     *
     * revokeRepositoryPermissionsForUser
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $name the name of the user (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function revokeRepositoryPermissionsForUser($project_key, $repository_slug, $name = null)
    {
        list($response) = $this->revokeRepositoryPermissionsForUserWithHttpInfo($project_key, $repository_slug, $name);
        return $response;
    }

    /**
     * Operation revokeRepositoryPermissionsForUserWithHttpInfo
     *
     * revokeRepositoryPermissionsForUser
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $name the name of the user (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function revokeRepositoryPermissionsForUserWithHttpInfo($project_key, $repository_slug, $name = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling revokeRepositoryPermissionsForUser');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling revokeRepositoryPermissionsForUser');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation setRepositoryDefaultBranch
     *
     * setRepositoryDefaultBranch
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function setRepositoryDefaultBranch($dynamic, $project_key, $repository_slug)
    {
        list($response) = $this->setRepositoryDefaultBranchWithHttpInfo($dynamic, $project_key, $repository_slug);
        return $response;
    }

    /**
     * Operation setRepositoryDefaultBranchWithHttpInfo
     *
     * setRepositoryDefaultBranch
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRepositoryDefaultBranchWithHttpInfo($dynamic, $project_key, $repository_slug)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling setRepositoryDefaultBranch');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling setRepositoryDefaultBranch');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling setRepositoryDefaultBranch');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches/default";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches/default'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation setRepositoryHookSettings
     *
     * setRepositoryHookSettings
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function setRepositoryHookSettings($dynamic, $project_key, $repository_slug, $hook_key)
    {
        list($response) = $this->setRepositoryHookSettingsWithHttpInfo($dynamic, $project_key, $repository_slug, $hook_key);
        return $response;
    }

    /**
     * Operation setRepositoryHookSettingsWithHttpInfo
     *
     * setRepositoryHookSettings
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $hook_key  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRepositoryHookSettingsWithHttpInfo($dynamic, $project_key, $repository_slug, $hook_key)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling setRepositoryHookSettings');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling setRepositoryHookSettings');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling setRepositoryHookSettings');
        }
        // verify the required parameter 'hook_key' is set
        if ($hook_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $hook_key when calling setRepositoryHookSettings');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($hook_key !== null) {
            $resourcePath = str_replace(
                "{" . "hookKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($hook_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation setRepositoryPermissionForGroup
     *
     * setRepositoryPermissionForGroup
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $permission the permission to grant (optional)
     * @param string $name the names of the groups (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function setRepositoryPermissionForGroup($project_key, $repository_slug, $permission = null, $name = null)
    {
        list($response) = $this->setRepositoryPermissionForGroupWithHttpInfo($project_key, $repository_slug, $permission, $name);
        return $response;
    }

    /**
     * Operation setRepositoryPermissionForGroupWithHttpInfo
     *
     * setRepositoryPermissionForGroup
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $permission the permission to grant (optional)
     * @param string $name the names of the groups (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRepositoryPermissionForGroupWithHttpInfo($project_key, $repository_slug, $permission = null, $name = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling setRepositoryPermissionForGroup');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling setRepositoryPermissionForGroup');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($permission !== null) {
            $queryParams['permission'] = $this->apiClient->getSerializer()->toQueryValue($permission);
        }
        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation setRepositoryPermissionForUser
     *
     * setRepositoryPermissionForUser
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $name the names of the users (optional)
     * @param string $permission the permission to grant (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function setRepositoryPermissionForUser($project_key, $repository_slug, $name = null, $permission = null)
    {
        list($response) = $this->setRepositoryPermissionForUserWithHttpInfo($project_key, $repository_slug, $name, $permission);
        return $response;
    }

    /**
     * Operation setRepositoryPermissionForUserWithHttpInfo
     *
     * setRepositoryPermissionForUser
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $name the names of the users (optional)
     * @param string $permission the permission to grant (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function setRepositoryPermissionForUserWithHttpInfo($project_key, $repository_slug, $name = null, $permission = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling setRepositoryPermissionForUser');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling setRepositoryPermissionForUser');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($name !== null) {
            $queryParams['name'] = $this->apiClient->getSerializer()->toQueryValue($name);
        }
        // query params
        if ($permission !== null) {
            $queryParams['permission'] = $this->apiClient->getSerializer()->toQueryValue($permission);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation unwatchRepositoryCommit
     *
     * unwatchRepositoryCommit
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function unwatchRepositoryCommit($project_key, $repository_slug, $commit_id)
    {
        list($response) = $this->unwatchRepositoryCommitWithHttpInfo($project_key, $repository_slug, $commit_id);
        return $response;
    }

    /**
     * Operation unwatchRepositoryCommitWithHttpInfo
     *
     * unwatchRepositoryCommit
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function unwatchRepositoryCommitWithHttpInfo($project_key, $repository_slug, $commit_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling unwatchRepositoryCommit');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling unwatchRepositoryCommit');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling unwatchRepositoryCommit');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateRepository
     *
     * updateRepository
     *
     * @param object $dynamic  (required)
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function updateRepository($dynamic, $repository_slug, $project_key)
    {
        list($response) = $this->updateRepositoryWithHttpInfo($dynamic, $repository_slug, $project_key);
        return $response;
    }

    /**
     * Operation updateRepositoryWithHttpInfo
     *
     * updateRepository
     *
     * @param object $dynamic  (required)
     * @param string $repository_slug the repository slug (required)
     * @param string $project_key the parent project key (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRepositoryWithHttpInfo($dynamic, $repository_slug, $project_key)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling updateRepository');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling updateRepository');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling updateRepository');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updateRepositoryCommitComment
     *
     * updateRepositoryCommitComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @param int $comment_id the ID of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function updateRepositoryCommitComment($dynamic, $project_key, $repository_slug, $commit_id, $comment_id)
    {
        list($response) = $this->updateRepositoryCommitCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $commit_id, $comment_id);
        return $response;
    }

    /**
     * Operation updateRepositoryCommitCommentWithHttpInfo
     *
     * updateRepositoryCommitComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @param int $comment_id the ID of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateRepositoryCommitCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $commit_id, $comment_id)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling updateRepositoryCommitComment');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling updateRepositoryCommitComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling updateRepositoryCommitComment');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling updateRepositoryCommitComment');
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $comment_id when calling updateRepositoryCommitComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                "{" . "commentId" . "}",
                $this->apiClient->getSerializer()->toPathValue($comment_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation watchRepositoryCommit
     *
     * watchRepositoryCommit
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function watchRepositoryCommit($project_key, $repository_slug, $commit_id)
    {
        list($response) = $this->watchRepositoryCommitWithHttpInfo($project_key, $repository_slug, $commit_id);
        return $response;
    }

    /**
     * Operation watchRepositoryCommitWithHttpInfo
     *
     * watchRepositoryCommit
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $commit_id the &lt;i&gt;full {@link Changeset#getId() ID}&lt;/i&gt; of the commit within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchRepositoryCommitWithHttpInfo($project_key, $repository_slug, $commit_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling watchRepositoryCommit');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling watchRepositoryCommit');
        }
        // verify the required parameter 'commit_id' is set
        if ($commit_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $commit_id when calling watchRepositoryCommit');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($commit_id !== null) {
            $resourcePath = str_replace(
                "{" . "commitId" . "}",
                $this->apiClient->getSerializer()->toPathValue($commit_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
