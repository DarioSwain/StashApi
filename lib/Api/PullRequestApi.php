<?php
/**
 * PullRequestApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Stash API
 *
 * REST-ish endpoint for interacting with Stash
 *
 * OpenAPI spec version: 1.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use \Swagger\Client\ApiClient;
use \Swagger\Client\ApiException;
use \Swagger\Client\Configuration;
use \Swagger\Client\ObjectSerializer;

/**
 * PullRequestApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class PullRequestApi
{
    /**
     * API Client
     *
     * @var \Swagger\Client\ApiClient instance of the ApiClient
     */
    protected $apiClient;

    /**
     * Constructor
     *
     * @param \Swagger\Client\ApiClient|null $apiClient The api client to use
     */
    public function __construct(\Swagger\Client\ApiClient $apiClient = null)
    {
        if ($apiClient === null) {
            $apiClient = new ApiClient();
        }

        $this->apiClient = $apiClient;
    }

    /**
     * Get API client
     *
     * @return \Swagger\Client\ApiClient get the API client
     */
    public function getApiClient()
    {
        return $this->apiClient;
    }

    /**
     * Set the API client
     *
     * @param \Swagger\Client\ApiClient $apiClient set the API client
     *
     * @return PullRequestApi
     */
    public function setApiClient(\Swagger\Client\ApiClient $apiClient)
    {
        $this->apiClient = $apiClient;
        return $this;
    }

    /**
     * Operation approvePullRequest
     *
     * approvePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function approvePullRequest($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->approvePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation approvePullRequestWithHttpInfo
     *
     * approvePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function approvePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling approvePullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling approvePullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling approvePullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation assignPullRequestParticipantRole
     *
     * assignPullRequestParticipantRole
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function assignPullRequestParticipantRole($dynamic, $project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->assignPullRequestParticipantRoleWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation assignPullRequestParticipantRoleWithHttpInfo
     *
     * assignPullRequestParticipantRole
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function assignPullRequestParticipantRoleWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling assignPullRequestParticipantRole');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling assignPullRequestParticipantRole');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling assignPullRequestParticipantRole');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling assignPullRequestParticipantRole');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation canMergePullRequest
     *
     * canMergePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function canMergePullRequest($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->canMergePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation canMergePullRequestWithHttpInfo
     *
     * canMergePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function canMergePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling canMergePullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling canMergePullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling canMergePullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation countPullRequestTasks
     *
     * countPullRequestTasks
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function countPullRequestTasks($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->countPullRequestTasksWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation countPullRequestTasksWithHttpInfo
     *
     * countPullRequestTasks
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function countPullRequestTasksWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling countPullRequestTasks');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling countPullRequestTasks');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling countPullRequestTasks');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/tasks/count";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/tasks/count'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createPullRequest
     *
     * createPullRequest
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function createPullRequest($dynamic, $project_key, $repository_slug)
    {
        list($response) = $this->createPullRequestWithHttpInfo($dynamic, $project_key, $repository_slug);
        return $response;
    }

    /**
     * Operation createPullRequestWithHttpInfo
     *
     * createPullRequest
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPullRequestWithHttpInfo($dynamic, $project_key, $repository_slug)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling createPullRequest');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling createPullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling createPullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation createPullRequestComment
     *
     * createPullRequestComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function createPullRequestComment($dynamic, $project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->createPullRequestCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation createPullRequestCommentWithHttpInfo
     *
     * createPullRequestComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function createPullRequestCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling createPullRequestComment');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling createPullRequestComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling createPullRequestComment');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling createPullRequestComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation declinePullRequest
     *
     * declinePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @param int $version the current version of the pull request. If the server&#39;s version isn&#39;t the same as the specified                 version the operation will fail. To determine the current version of the pull request it should be                 fetched from the server prior to this operation. Look for the &#39;version&#39; attribute in the returned                 JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function declinePullRequest($project_key, $repository_slug, $pull_request_id, $version = null)
    {
        list($response) = $this->declinePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id, $version);
        return $response;
    }

    /**
     * Operation declinePullRequestWithHttpInfo
     *
     * declinePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @param int $version the current version of the pull request. If the server&#39;s version isn&#39;t the same as the specified                 version the operation will fail. To determine the current version of the pull request it should be                 fetched from the server prior to this operation. Look for the &#39;version&#39; attribute in the returned                 JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function declinePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id, $version = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling declinePullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling declinePullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling declinePullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/decline";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($version !== null) {
            $queryParams['version'] = $this->apiClient->getSerializer()->toQueryValue($version);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/decline'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation deletePullRequestComment
     *
     * deletePullRequestComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $comment_id the id of the comment to retrieve (required)
     * @param int $version The expected version of the comment. This must match the server&#39;s version of the comment or                       the delete will fail. To determine the current version of the comment, the comment should be                       fetched from the server prior to the delete. Look for the &#39;version&#39; attribute in the                       returned JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function deletePullRequestComment($project_key, $repository_slug, $pull_request_id, $comment_id, $version = null)
    {
        list($response) = $this->deletePullRequestCommentWithHttpInfo($project_key, $repository_slug, $pull_request_id, $comment_id, $version);
        return $response;
    }

    /**
     * Operation deletePullRequestCommentWithHttpInfo
     *
     * deletePullRequestComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $comment_id the id of the comment to retrieve (required)
     * @param int $version The expected version of the comment. This must match the server&#39;s version of the comment or                       the delete will fail. To determine the current version of the comment, the comment should be                       fetched from the server prior to the delete. Look for the &#39;version&#39; attribute in the                       returned JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function deletePullRequestCommentWithHttpInfo($project_key, $repository_slug, $pull_request_id, $comment_id, $version = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling deletePullRequestComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling deletePullRequestComment');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling deletePullRequestComment');
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $comment_id when calling deletePullRequestComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($version !== null) {
            $queryParams['version'] = $this->apiClient->getSerializer()->toQueryValue($version);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                "{" . "commentId" . "}",
                $this->apiClient->getSerializer()->toPathValue($comment_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequest
     *
     * getPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequest($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->getPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation getPullRequestWithHttpInfo
     *
     * getPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestActivities
     *
     * getPullRequestActivities
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $from_id (optional) the id of the activity item to use as the first item in the returned page (optional)
     * @param string $from_type (required if &lt;strong&gt;fromId&lt;/strong&gt; is present) the type of the activity item specified by                  &lt;strong&gt;fromId&lt;/strong&gt; (either &lt;strong&gt;COMMENT&lt;/strong&gt; or &lt;strong&gt;ACTIVITY&lt;/strong&gt;) (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestActivities($project_key, $repository_slug, $pull_request_id, $from_id = null, $from_type = null)
    {
        list($response) = $this->getPullRequestActivitiesWithHttpInfo($project_key, $repository_slug, $pull_request_id, $from_id, $from_type);
        return $response;
    }

    /**
     * Operation getPullRequestActivitiesWithHttpInfo
     *
     * getPullRequestActivities
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $from_id (optional) the id of the activity item to use as the first item in the returned page (optional)
     * @param string $from_type (required if &lt;strong&gt;fromId&lt;/strong&gt; is present) the type of the activity item specified by                  &lt;strong&gt;fromId&lt;/strong&gt; (either &lt;strong&gt;COMMENT&lt;/strong&gt; or &lt;strong&gt;ACTIVITY&lt;/strong&gt;) (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestActivitiesWithHttpInfo($project_key, $repository_slug, $pull_request_id, $from_id = null, $from_type = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestActivities');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestActivities');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestActivities');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/activities";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($from_id !== null) {
            $queryParams['fromId'] = $this->apiClient->getSerializer()->toQueryValue($from_id);
        }
        // query params
        if ($from_type !== null) {
            $queryParams['fromType'] = $this->apiClient->getSerializer()->toQueryValue($from_type);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/activities'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestChanges
     *
     * getPullRequestChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @param bool $with_comments {@code true} to apply comment counts in the changes (the default); otherwise, {@code false}                      to stream changes without comment counts (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestChanges($project_key, $repository_slug, $pull_request_id, $with_comments = null)
    {
        list($response) = $this->getPullRequestChangesWithHttpInfo($project_key, $repository_slug, $pull_request_id, $with_comments);
        return $response;
    }

    /**
     * Operation getPullRequestChangesWithHttpInfo
     *
     * getPullRequestChanges
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @param bool $with_comments {@code true} to apply comment counts in the changes (the default); otherwise, {@code false}                      to stream changes without comment counts (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestChangesWithHttpInfo($project_key, $repository_slug, $pull_request_id, $with_comments = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestChanges');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestChanges');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestChanges');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/changes";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($with_comments !== null) {
            $queryParams['withComments'] = $this->apiClient->getSerializer()->toQueryValue($with_comments);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/changes'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestComment
     *
     * getPullRequestComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $comment_id the id of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestComment($project_key, $repository_slug, $pull_request_id, $comment_id)
    {
        list($response) = $this->getPullRequestCommentWithHttpInfo($project_key, $repository_slug, $pull_request_id, $comment_id);
        return $response;
    }

    /**
     * Operation getPullRequestCommentWithHttpInfo
     *
     * getPullRequestComment
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $comment_id the id of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestCommentWithHttpInfo($project_key, $repository_slug, $pull_request_id, $comment_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestComment');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestComment');
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $comment_id when calling getPullRequestComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                "{" . "commentId" . "}",
                $this->apiClient->getSerializer()->toPathValue($comment_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestComments
     *
     * getPullRequestComments
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @param string $path  (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return object
     */
    public function getPullRequestComments($project_key, $repository_slug, $pull_request_id, $path = null)
    {
        list($response) = $this->getPullRequestCommentsWithHttpInfo($project_key, $repository_slug, $pull_request_id, $path);
        return $response;
    }

    /**
     * Operation getPullRequestCommentsWithHttpInfo
     *
     * getPullRequestComments
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @param string $path  (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestCommentsWithHttpInfo($project_key, $repository_slug, $pull_request_id, $path = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestComments');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestComments');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestComments');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($path !== null) {
            $queryParams['path'] = $this->apiClient->getSerializer()->toQueryValue($path);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'object',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'object', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'object', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestCommits
     *
     * getPullRequestCommits
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @param bool $with_counts if set to true, the service will add \&quot;authorCount\&quot; and \&quot;totalCount\&quot; at the end of the page.                      \&quot;authorCount\&quot; is the number of different authors and \&quot;totalCount\&quot; is the total number of changesets. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestCommits($project_key, $repository_slug, $pull_request_id, $with_counts = null)
    {
        list($response) = $this->getPullRequestCommitsWithHttpInfo($project_key, $repository_slug, $pull_request_id, $with_counts);
        return $response;
    }

    /**
     * Operation getPullRequestCommitsWithHttpInfo
     *
     * getPullRequestCommits
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id  (required)
     * @param bool $with_counts if set to true, the service will add \&quot;authorCount\&quot; and \&quot;totalCount\&quot; at the end of the page.                      \&quot;authorCount\&quot; is the number of different authors and \&quot;totalCount\&quot; is the total number of changesets. (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestCommitsWithHttpInfo($project_key, $repository_slug, $pull_request_id, $with_counts = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestCommits');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestCommits');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestCommits');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/commits";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($with_counts !== null) {
            $queryParams['withCounts'] = $this->apiClient->getSerializer()->toQueryValue($with_counts);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/commits'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestDiff
     *
     * getPullRequestDiff
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $src_path the previous path to the file, if the file has been copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise, &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestDiff($project_key, $repository_slug, $pull_request_id, $context_lines = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        list($response) = $this->getPullRequestDiffWithHttpInfo($project_key, $repository_slug, $pull_request_id, $context_lines, $src_path, $whitespace, $with_comments);
        return $response;
    }

    /**
     * Operation getPullRequestDiffWithHttpInfo
     *
     * getPullRequestDiff
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $src_path the previous path to the file, if the file has been copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise, &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestDiffWithHttpInfo($project_key, $repository_slug, $pull_request_id, $context_lines = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestDiff');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestDiff');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestDiff');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // query params
        if ($with_comments !== null) {
            $queryParams['withComments'] = $this->apiClient->getSerializer()->toQueryValue($with_comments);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestDiffByPath
     *
     * getPullRequestDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @param string $path the path to the file which should be diffed (optional) (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $src_path the previous path to the file, if the file has been copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise, &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestDiffByPath($project_key, $repository_slug, $pull_request_id, $path, $context_lines = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        list($response) = $this->getPullRequestDiffByPathWithHttpInfo($project_key, $repository_slug, $pull_request_id, $path, $context_lines, $src_path, $whitespace, $with_comments);
        return $response;
    }

    /**
     * Operation getPullRequestDiffByPathWithHttpInfo
     *
     * getPullRequestDiffByPath
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @param string $path the path to the file which should be diffed (optional) (required)
     * @param int $context_lines the number of context lines to include around added/removed lines in the diff (optional, default to -1)
     * @param string $src_path the previous path to the file, if the file has been copied, moved or renamed (optional)
     * @param string $whitespace optional whitespace flag which can be set to &lt;code&gt;ignore-all&lt;/code&gt; (optional)
     * @param bool $with_comments &lt;code&gt;true&lt;/code&gt; to embed comments in the diff (the default); otherwise, &lt;code&gt;false&lt;/code&gt;                      to stream the diff without comments (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestDiffByPathWithHttpInfo($project_key, $repository_slug, $pull_request_id, $path, $context_lines = null, $src_path = null, $whitespace = null, $with_comments = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestDiffByPath');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestDiffByPath');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestDiffByPath');
        }
        // verify the required parameter 'path' is set
        if ($path === null) {
            throw new \InvalidArgumentException('Missing the required parameter $path when calling getPullRequestDiffByPath');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff/{path}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($context_lines !== null) {
            $queryParams['contextLines'] = $this->apiClient->getSerializer()->toQueryValue($context_lines);
        }
        // query params
        if ($src_path !== null) {
            $queryParams['srcPath'] = $this->apiClient->getSerializer()->toQueryValue($src_path);
        }
        // query params
        if ($whitespace !== null) {
            $queryParams['whitespace'] = $this->apiClient->getSerializer()->toQueryValue($whitespace);
        }
        // query params
        if ($with_comments !== null) {
            $queryParams['withComments'] = $this->apiClient->getSerializer()->toQueryValue($with_comments);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // path params
        if ($path !== null) {
            $resourcePath = str_replace(
                "{" . "path" . "}",
                $this->apiClient->getSerializer()->toPathValue($path),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff/{path}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequestTasks
     *
     * getPullRequestTasks
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequestTasks($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->getPullRequestTasksWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation getPullRequestTasksWithHttpInfo
     *
     * getPullRequestTasks
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestTasksWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequestTasks');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequestTasks');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling getPullRequestTasks');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/tasks";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/tasks'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation getPullRequests
     *
     * getPullRequests
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $direction (optional, defaults to &lt;strong&gt;INCOMING&lt;/strong&gt;) the direction relative to the specified                   repository. Either &lt;strong&gt;INCOMING&lt;/strong&gt; or &lt;strong&gt;OUTGOING&lt;/strong&gt;. (optional, default to incoming)
     * @param string $at (optional) a &lt;i&gt;fully-qualified&lt;/i&gt; branch ID to find pull requests to or from,            such as {@code refs/heads/master} (optional)
     * @param string $state (optional, defaults to &lt;strong&gt;OPEN&lt;/strong&gt;). Supply &lt;strong&gt;ALL&lt;/strong&gt; to return pull request                in any state. If a state is supplied only pull requests in the specified state will be returned.                Either &lt;strong&gt;OPEN&lt;/strong&gt;, &lt;strong&gt;DECLINED&lt;/strong&gt; or &lt;strong&gt;MERGED&lt;/strong&gt;. (optional)
     * @param string $order (optional) the order to return pull requests in, either &lt;strong&gt;OLDEST&lt;/strong&gt; (as in: \&quot;oldest               first\&quot;) or &lt;strong&gt;NEWEST&lt;/strong&gt;. (optional)
     * @param bool $with_attributes (optional) defaults to true, whether to return additional pull request attributes (optional, default to true)
     * @param bool $with_properties (optional) defaults to true, whether to return additional pull request properties (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function getPullRequests($project_key, $repository_slug, $direction = null, $at = null, $state = null, $order = null, $with_attributes = null, $with_properties = null)
    {
        list($response) = $this->getPullRequestsWithHttpInfo($project_key, $repository_slug, $direction, $at, $state, $order, $with_attributes, $with_properties);
        return $response;
    }

    /**
     * Operation getPullRequestsWithHttpInfo
     *
     * getPullRequests
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $direction (optional, defaults to &lt;strong&gt;INCOMING&lt;/strong&gt;) the direction relative to the specified                   repository. Either &lt;strong&gt;INCOMING&lt;/strong&gt; or &lt;strong&gt;OUTGOING&lt;/strong&gt;. (optional, default to incoming)
     * @param string $at (optional) a &lt;i&gt;fully-qualified&lt;/i&gt; branch ID to find pull requests to or from,            such as {@code refs/heads/master} (optional)
     * @param string $state (optional, defaults to &lt;strong&gt;OPEN&lt;/strong&gt;). Supply &lt;strong&gt;ALL&lt;/strong&gt; to return pull request                in any state. If a state is supplied only pull requests in the specified state will be returned.                Either &lt;strong&gt;OPEN&lt;/strong&gt;, &lt;strong&gt;DECLINED&lt;/strong&gt; or &lt;strong&gt;MERGED&lt;/strong&gt;. (optional)
     * @param string $order (optional) the order to return pull requests in, either &lt;strong&gt;OLDEST&lt;/strong&gt; (as in: \&quot;oldest               first\&quot;) or &lt;strong&gt;NEWEST&lt;/strong&gt;. (optional)
     * @param bool $with_attributes (optional) defaults to true, whether to return additional pull request attributes (optional, default to true)
     * @param bool $with_properties (optional) defaults to true, whether to return additional pull request properties (optional, default to true)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function getPullRequestsWithHttpInfo($project_key, $repository_slug, $direction = null, $at = null, $state = null, $order = null, $with_attributes = null, $with_properties = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling getPullRequests');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling getPullRequests');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($direction !== null) {
            $queryParams['direction'] = $this->apiClient->getSerializer()->toQueryValue($direction);
        }
        // query params
        if ($at !== null) {
            $queryParams['at'] = $this->apiClient->getSerializer()->toQueryValue($at);
        }
        // query params
        if ($state !== null) {
            $queryParams['state'] = $this->apiClient->getSerializer()->toQueryValue($state);
        }
        // query params
        if ($order !== null) {
            $queryParams['order'] = $this->apiClient->getSerializer()->toQueryValue($order);
        }
        // query params
        if ($with_attributes !== null) {
            $queryParams['withAttributes'] = $this->apiClient->getSerializer()->toQueryValue($with_attributes);
        }
        // query params
        if ($with_properties !== null) {
            $queryParams['withProperties'] = $this->apiClient->getSerializer()->toQueryValue($with_properties);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation listPullRequestParticipants
     *
     * listPullRequestParticipants
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function listPullRequestParticipants($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->listPullRequestParticipantsWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation listPullRequestParticipantsWithHttpInfo
     *
     * listPullRequestParticipants
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function listPullRequestParticipantsWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling listPullRequestParticipants');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling listPullRequestParticipants');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling listPullRequestParticipants');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'GET',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation mergePullRequest
     *
     * mergePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $version the current version of the pull request. If the server&#39;s version isn&#39;t the same as the specified                 version the operation will fail. To determine the current version of the pull request it should be                 fetched from the server prior to this operation. Look for the &#39;version&#39; attribute in the returned                 JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function mergePullRequest($project_key, $repository_slug, $pull_request_id, $version = null)
    {
        list($response) = $this->mergePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id, $version);
        return $response;
    }

    /**
     * Operation mergePullRequestWithHttpInfo
     *
     * mergePullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $version the current version of the pull request. If the server&#39;s version isn&#39;t the same as the specified                 version the operation will fail. To determine the current version of the pull request it should be                 fetched from the server prior to this operation. Look for the &#39;version&#39; attribute in the returned                 JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function mergePullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id, $version = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling mergePullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling mergePullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling mergePullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($version !== null) {
            $queryParams['version'] = $this->apiClient->getSerializer()->toQueryValue($version);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation reopenPullRequest
     *
     * reopenPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $version the current version of the pull request. If the server&#39;s version isn&#39;t the same as the specified                 version the operation will fail. To determine the current version of the pull request it should be                 fetched from the server prior to this operation. Look for the &#39;version&#39; attribute in the returned                 JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function reopenPullRequest($project_key, $repository_slug, $pull_request_id, $version = null)
    {
        list($response) = $this->reopenPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id, $version);
        return $response;
    }

    /**
     * Operation reopenPullRequestWithHttpInfo
     *
     * reopenPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $version the current version of the pull request. If the server&#39;s version isn&#39;t the same as the specified                 version the operation will fail. To determine the current version of the pull request it should be                 fetched from the server prior to this operation. Look for the &#39;version&#39; attribute in the returned                 JSON structure. (optional, default to -1)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function reopenPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id, $version = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling reopenPullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling reopenPullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling reopenPullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/reopen";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($version !== null) {
            $queryParams['version'] = $this->apiClient->getSerializer()->toQueryValue($version);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/reopen'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation unassignPullRequestParticipantRole
     *
     * unassignPullRequestParticipantRole
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param string $username the participant&#39;s user name (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function unassignPullRequestParticipantRole($project_key, $repository_slug, $pull_request_id, $username = null)
    {
        list($response) = $this->unassignPullRequestParticipantRoleWithHttpInfo($project_key, $repository_slug, $pull_request_id, $username);
        return $response;
    }

    /**
     * Operation unassignPullRequestParticipantRoleWithHttpInfo
     *
     * unassignPullRequestParticipantRole
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param string $username the participant&#39;s user name (optional)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function unassignPullRequestParticipantRoleWithHttpInfo($project_key, $repository_slug, $pull_request_id, $username = null)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling unassignPullRequestParticipantRole');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling unassignPullRequestParticipantRole');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling unassignPullRequestParticipantRole');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // query params
        if ($username !== null) {
            $queryParams['username'] = $this->apiClient->getSerializer()->toQueryValue($username);
        }
        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation unwatchPullRequest
     *
     * unwatchPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function unwatchPullRequest($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->unwatchPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation unwatchPullRequestWithHttpInfo
     *
     * unwatchPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function unwatchPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling unwatchPullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling unwatchPullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling unwatchPullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updatePullRequest
     *
     * updatePullRequest
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function updatePullRequest($dynamic, $project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->updatePullRequestWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation updatePullRequestWithHttpInfo
     *
     * updatePullRequest
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param string $pull_request_id  (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePullRequestWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling updatePullRequest');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling updatePullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling updatePullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling updatePullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation updatePullRequestComment
     *
     * updatePullRequestComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $comment_id the id of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function updatePullRequestComment($dynamic, $project_key, $repository_slug, $pull_request_id, $comment_id)
    {
        list($response) = $this->updatePullRequestCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id, $comment_id);
        return $response;
    }

    /**
     * Operation updatePullRequestCommentWithHttpInfo
     *
     * updatePullRequestComment
     *
     * @param object $dynamic  (required)
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @param int $comment_id the id of the comment to retrieve (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function updatePullRequestCommentWithHttpInfo($dynamic, $project_key, $repository_slug, $pull_request_id, $comment_id)
    {
        // verify the required parameter 'dynamic' is set
        if ($dynamic === null) {
            throw new \InvalidArgumentException('Missing the required parameter $dynamic when calling updatePullRequestComment');
        }
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling updatePullRequestComment');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling updatePullRequestComment');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling updatePullRequestComment');
        }
        // verify the required parameter 'comment_id' is set
        if ($comment_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $comment_id when calling updatePullRequestComment');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // path params
        if ($comment_id !== null) {
            $resourcePath = str_replace(
                "{" . "commentId" . "}",
                $this->apiClient->getSerializer()->toPathValue($comment_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        // body params
        $_tempBody = null;
        if (isset($dynamic)) {
            $_tempBody = $dynamic;
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'PUT',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation watchPullRequest
     *
     * watchPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function watchPullRequest($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->watchPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation watchPullRequestWithHttpInfo
     *
     * watchPullRequest
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function watchPullRequestWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling watchPullRequest');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling watchPullRequest');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling watchPullRequest');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'POST',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }

    /**
     * Operation withdrawPullRequestApproval
     *
     * withdrawPullRequestApproval
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return string
     */
    public function withdrawPullRequestApproval($project_key, $repository_slug, $pull_request_id)
    {
        list($response) = $this->withdrawPullRequestApprovalWithHttpInfo($project_key, $repository_slug, $pull_request_id);
        return $response;
    }

    /**
     * Operation withdrawPullRequestApprovalWithHttpInfo
     *
     * withdrawPullRequestApproval
     *
     * @param string $project_key  (required)
     * @param string $repository_slug  (required)
     * @param int $pull_request_id the id of the pull request within the repository (required)
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @return array of string, HTTP status code, HTTP response headers (array of strings)
     */
    public function withdrawPullRequestApprovalWithHttpInfo($project_key, $repository_slug, $pull_request_id)
    {
        // verify the required parameter 'project_key' is set
        if ($project_key === null) {
            throw new \InvalidArgumentException('Missing the required parameter $project_key when calling withdrawPullRequestApproval');
        }
        // verify the required parameter 'repository_slug' is set
        if ($repository_slug === null) {
            throw new \InvalidArgumentException('Missing the required parameter $repository_slug when calling withdrawPullRequestApproval');
        }
        // verify the required parameter 'pull_request_id' is set
        if ($pull_request_id === null) {
            throw new \InvalidArgumentException('Missing the required parameter $pull_request_id when calling withdrawPullRequestApproval');
        }
        // parse inputs
        $resourcePath = "/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve";
        $httpBody = '';
        $queryParams = [];
        $headerParams = [];
        $formParams = [];
        $_header_accept = $this->apiClient->selectHeaderAccept(['application/json']);
        if (!is_null($_header_accept)) {
            $headerParams['Accept'] = $_header_accept;
        }
        $headerParams['Content-Type'] = $this->apiClient->selectHeaderContentType(['application/json']);

        // path params
        if ($project_key !== null) {
            $resourcePath = str_replace(
                "{" . "projectKey" . "}",
                $this->apiClient->getSerializer()->toPathValue($project_key),
                $resourcePath
            );
        }
        // path params
        if ($repository_slug !== null) {
            $resourcePath = str_replace(
                "{" . "repositorySlug" . "}",
                $this->apiClient->getSerializer()->toPathValue($repository_slug),
                $resourcePath
            );
        }
        // path params
        if ($pull_request_id !== null) {
            $resourcePath = str_replace(
                "{" . "pullRequestId" . "}",
                $this->apiClient->getSerializer()->toPathValue($pull_request_id),
                $resourcePath
            );
        }
        // default format to json
        $resourcePath = str_replace("{format}", "json", $resourcePath);

        
        // for model (json/xml)
        if (isset($_tempBody)) {
            $httpBody = $_tempBody; // $_tempBody is the method argument, if present
        } elseif (count($formParams) > 0) {
            $httpBody = $formParams; // for HTTP post (form)
        }
        // this endpoint requires HTTP basic authentication
        if (strlen($this->apiClient->getConfig()->getUsername()) !== 0 or strlen($this->apiClient->getConfig()->getPassword()) !== 0) {
            $headerParams['Authorization'] = 'Basic ' . base64_encode($this->apiClient->getConfig()->getUsername() . ":" . $this->apiClient->getConfig()->getPassword());
        }
        // make the API Call
        try {
            list($response, $statusCode, $httpHeader) = $this->apiClient->callApi(
                $resourcePath,
                'DELETE',
                $queryParams,
                $httpBody,
                $headerParams,
                'string',
                '/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve'
            );

            return [$this->apiClient->getSerializer()->deserialize($response, 'string', $httpHeader), $statusCode, $httpHeader];
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = $this->apiClient->getSerializer()->deserialize($e->getResponseBody(), 'string', $e->getResponseHeaders());
                    $e->setResponseObject($data);
                    break;
            }

            throw $e;
        }
    }
}
