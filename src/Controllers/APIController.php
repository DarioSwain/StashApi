<?php
/*
 * StashAPILib
 *
 * This file was automatically generated by APIMATIC v2.0 ( https://apimatic.io ).
 */

namespace StashAPILib\Controllers;

use StashAPILib\APIException;
use StashAPILib\APIHelper;
use StashAPILib\Configuration;
use StashAPILib\Models;
use StashAPILib\Exceptions;
use StashAPILib\Http\HttpRequest;
use StashAPILib\Http\HttpResponse;
use StashAPILib\Http\HttpMethod;
use StashAPILib\Http\HttpContext;
use Unirest\Request;

/**
 * @todo Add a general description for this controller.
 */
class APIController extends BaseController
{
    /**
     * @var APIController The reference to *Singleton* instance of this class
     */
    private static $instance;

    /**
     * Returns the *Singleton* instance of this class.
     * @return APIController The *Singleton* instance.
     */
    public static function getInstance()
    {
        if (null === static::$instance) {
            static::$instance = new static();
        }
        
        return static::$instance;
    }

    /**
     * Retrieve a page of changes made in a specified commit.
     * <p>
     * <strong>Note:</strong> The implementation will apply a hard cap ({@code page.max.changes}) and it
     * is not
     * possible to request subsequent content when that cap is exceeded.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $since          (optional) the commit to which <code>until</code> should be compared to produce a
     *                               page of changes.                      If not specified the commit's first parent
     *                               is assumed (if one exists)
     * @param bool   $withComments   (optional) {@code true} to apply comment counts in the changes (the default);
     *                               otherwise, {@code false}                      to stream changes without comment
     *                               counts
     * @param string $commitId       (optional) the commit to retrieve changes for
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getChanges(
        $projectKey,
        $repositorySlug,
        $since = null,
        $withComments = true,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/changes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'since'          => $since,
            'withComments'   => (null != $withComments) ? var_export($withComments, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Gets information about the nodes that currently make up the stash cluster.
     * <p>
     * The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getInformation()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/cluster';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves details about the current license, as well as the current status of the system with
     * regards to the
     * installed license. The status includes the current number of users applied toward the license limit,
     * as well
     * as any status messages about the license (warnings about expiry or user counts exceeding license
     * limits).
     * <p>
     * The authenticated user must have <b>ADMIN</b> permission. Unauthenticated users, and non-
     * administrators, are
     * not permitted to access license details.
     *
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function get()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/license';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Decodes the provided encoded license and sets it as the active license. If no license was provided,
     * a 400 is
     * returned. If the license cannot be decoded, or cannot be applied, a 409 is returned. Some possible
     * reasons a
     * license may not be applied include:
     * <ul>
     * <li>It is for a different product</li>
     * <li>It is already expired</li>
     * </ul>
     * Otherwise, if the license is updated successfully, details for the new license are returned with a
     * 200 response.
     * <p>
     * <b>Warning</b>: It is possible to downgrade the license during update, applying a license with a
     * lower number
     * of permitted users. If the number of currently-licensed users exceeds the limits of the new license,
     * pushing
     * will be disabled until the licensed user count is brought into compliance with the new license.
     * <p>
     * The authenticated user must have <b>SYS_ADMIN</b> permission. <b>ADMIN</b> users may <i>view</i>
     * the current
     * license details, but they may not <i>update</i> the license.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function update(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/license';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Make the authenticated user stop watching the specified pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteUnwatch(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Make the authenticated user watch the specified pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createWatch(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/watch';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Deletes the current mail configuration.
     * <p>
     * The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteMailConfig()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/mail-server';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves the current mail configuration.
     * 
     * The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getMailConfig()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/mail-server';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Updates the mail configuration
     * 
     * The authenticated user must have the <strong>SYS_ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetMailConfig(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/mail-server';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Clears the server email address.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteClearSenderAddress()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/mail-server/sender-address';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves the server email address
     *
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getSenderAddress()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/mail-server/sender-address';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Updates the server email address
     * 
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetSenderAddress(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/mail-server/sender-address';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>moduleKey</strong>.
     *
     * @param string $version (optional) optional version used for HTTP caching only - any non-blank version will
     *                        result in a large max-age Cache-Control header.                 Note that this does not
     *                        affect the Last-Modified header.
     * @param string $hookKey (optional) the complete module key of the hook module
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getAvatar(
        $version = null,
        $hookKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/hooks/{hookKey}/avatar';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'hookKey' => $hookKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'version' => $version,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified project.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     *
     * @param string $projectKey TODO: type description here
     * @param string $filter     (optional) if specified only group names containing the supplied string will be
     *                           returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroupsWithAnyPermission(
        $projectKey,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/groups';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'     => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Promote or demote a group's permission level for the specified project. Available project
     * permissions are:
     * <ul>
     * <li>PROJECT_READ</li>
     * <li>PROJECT_WRITE</li>
     * <li>PROJECT_ADMIN</li>
     * </ul>
     * See the <a href="https://confluence.atlassian.
     * com/display/STASH/Managing+permissions+for+a+project">Stash documentation</a>
     * for a detailed explanation of what each permission entails.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource. In addition, a user may not demote a group's permission
     * level if their
     * own permission level would be reduced as a result.
     *
     * @param string $projectKey TODO: type description here
     * @param string $permission (optional) the permission to grant
     * @param string $name       (optional) the names of the groups
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetPermissionForGroups(
        $projectKey,
        $permission = null,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/groups';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'permission' => $permission,
            'name'       => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Revoke all permissions for the specified project for a group.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     * <p>
     * In addition, a user may not revoke a group's permissions if it will reduce their own permission
     * level.
     *
     * @param string $projectKey TODO: type description here
     * @param string $name       (optional) the name of the group
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRevokePermissionsForGroup(
        $projectKey,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/groups';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'       => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified project.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     *
     * @param string $projectKey TODO: type description here
     * @param string $filter     (optional) if specified only group names containing the supplied string will be
     *                           returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroupsWithoutAnyPermission(
        $projectKey,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/groups/none';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'     => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified project.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     *
     * @param string $projectKey TODO: type description here
     * @param string $filter     (optional) if specified only group names containing the supplied string will be
     *                           returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsersWithAnyPermission(
        $projectKey,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/users';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'     => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Promote or demote a user's permission level for the specified project. Available project permissions
     * are:
     * <ul>
     * <li>PROJECT_READ</li>
     * <li>PROJECT_WRITE</li>
     * <li>PROJECT_ADMIN</li>
     * </ul>
     * See the <a href="https://confluence.atlassian.
     * com/display/STASH/Managing+permissions+for+a+project">Stash documentation</a>
     * for a detailed explanation of what each permission entails.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource. In addition, a user may not reduce their own permission
     * level unless
     * they have a global permission that already implies that permission.
     *
     * @param string $projectKey TODO: type description here
     * @param string $name       (optional) the names of the users
     * @param string $permission (optional) the permission to grant
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetPermissionForUsers(
        $projectKey,
        $name = null,
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/users';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'       => $name,
            'permission' => $permission,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Revoke all permissions for the specified project for a user.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     * <p>
     * In addition, a user may not revoke their own project permissions if they do not have a higher
     * global permission.
     *
     * @param string $projectKey TODO: type description here
     * @param string $name       (optional) the name of the user
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRevokePermissionsForUser(
        $projectKey,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/users';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'       => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified project.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     *
     * @param string $projectKey TODO: type description here
     * @param string $filter     (optional) if specified only group names containing the supplied string will be
     *                           returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsersWithoutPermission(
        $projectKey,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/users/none';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'     => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Check whether the specified permission is the default permission (granted to all users) for a
     * project. Available
     * project permissions are:
     * <ul>
     * <li>PROJECT_READ</li>
     * <li>PROJECT_WRITE</li>
     * <li>PROJECT_ADMIN</li>
     * </ul>
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     *
     * @param string $projectKey TODO: type description here
     * @param string $permission (optional) the permission to grant
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getHasAllUserPermission(
        $projectKey,
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/{permission}/all';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            'permission' => $permission,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Grant or revoke a project permission to all users, i.e. set the default permission. Available
     * project permissions
     * are:
     * <ul>
     * <li>PROJECT_READ</li>
     * <li>PROJECT_WRITE</li>
     * <li>PROJECT_ADMIN</li>
     * </ul>
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project or a higher
     * global permission to call this resource.
     *
     * @param string $projectKey TODO: type description here
     * @param bool   $allow      (optional) <em>true</em> to grant the specified permission to all users, or
     *                           <em>false</em> to revoke it
     * @param string $permission (optional) the permission to grant
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function modifyAllUserPermission(
        $projectKey,
        $allow = null,
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/permissions/{permission}/all';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            'permission' => $permission,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'allow'      => var_export($allow, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Create a new task.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createTask(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/tasks';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Delete a task.
     * <p>
     * Note that only the task's creator, the context's author or an admin of the context's repository can
     * delete a
     * task. (For a pull request task, those are the task's creator, the pull request's author or an admin
     * on the
     * repository containing the pull request). Additionally a task cannot be deleted if it has already
     * been resolved.
     *
     * @param integer $taskId (optional) the id identifying the task to delete
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteTask(
        $taskId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/tasks/{taskId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'taskId' => $taskId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update a existing task.
     * <p>
     * As of Stash 3.3, only the state and text of a task can be updated.
     * <p>
     * Updating the state of a task is allowed for any user having <em>READ</em> access to the repository.
     * However only the task's creator, the context's author or an admin of the context's repository can
     * update the
     * task's text. (For a pull request task, those are the task's creator, the pull request's author or
     * an admin on the
     * repository containing the pull request). Additionally the task's text cannot be updated if it has
     * been resolved.
     *
     * @param object  $dynamic TODO: type description here
     * @param integer $taskId  (optional) the id identifying the task to delete
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateTask(
        $dynamic,
        $taskId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/tasks/{taskId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'taskId'  => $taskId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a existing task.
     *
     * @param integer $taskId (optional) the id identifying the task to delete
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getTask(
        $taskId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/tasks/{taskId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'taskId' => $taskId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Gets a diff of the changes available in the {@code from} changeset but not in the {@code to}
     * changeset.
     * <p>
     * If either the {@code from} or {@code to} changeset are not specified, they will be replaced by the
     * default branch of their containing repository.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $from           (optional) the source changeset (can be a partial/full changeset id or
     *                                qualified/unqualified ref name)
     * @param string  $to             (optional) the target changeset (can be a partial/full changeset id or
     *                                qualified/unqualified ref name)
     * @param string  $fromRepo       (optional) an optional parameter specifying the source repository containing the
     *                                source changeset                  if that changeset is not present in the current
     *                                repository; the repository can be specified                  by either its ID
     *                                <em>fromRepo=42</em> or by its project key plus its repo slug separated by
     *                                a slash: <em>fromRepo=projectKey/repoSlug</em>
     * @param string  $srcPath        (optional) TODO: type description here
     * @param integer $contextLines   (optional) an optional number of context lines to include around each added or
     *                                removed lines in the diff
     * @param string  $whitespace     (optional) an optional whitespace flag which can be set to <code>ignore-
     *                                all</code>
     * @param string  $path           (optional) the path to the file to diff (optional)
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $from = null,
        $to = null,
        $fromRepo = null,
        $srcPath = null,
        $contextLines = -1,
        $whitespace = null,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/diff{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'path'           => $path,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'from'           => $from,
            'to'             => $to,
            'fromRepo'       => $fromRepo,
            'srcPath'        => $srcPath,
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'whitespace'     => $whitespace,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Gets the file changes available in the {@code from} changeset but not in the {@code to} changeset.
     * <p>
     * If either the {@code from} or {@code to} changeset are not specified, they will be replaced by the
     * default branch of their containing repository.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $from           (optional) the source changeset (can be a partial/full changeset id or
     *                               qualified/unqualified ref name)
     * @param string $to             (optional) the target changeset (can be a partial/full changeset id or
     *                               qualified/unqualified ref name)
     * @param string $fromRepo       (optional) an optional parameter specifying the source repository containing the
     *                               source changeset                  if that changeset is not present in the current
     *                               repository; the repository can be specified                  by either its ID
     *                               <em>fromRepo=42</em> or by its project key plus its repo slug separated by
     *                               a slash: <em>fromRepo=projectKey/repoSlug</em>
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamChanges(
        $projectKey,
        $repositorySlug,
        $from = null,
        $to = null,
        $fromRepo = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/changes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'from'           => $from,
            'to'             => $to,
            'fromRepo'       => $fromRepo,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Gets the commits accessible from the {@code from} changeset but not in the {@code to} changeset.
     * <p>
     * If either the {@code from} or {@code to} changeset are not specified, they will be replaced by the
     * default branch of their containing repository.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $from           (optional) the source changeset (can be a partial/full changeset id or
     *                               qualified/unqualified ref name)
     * @param string $to             (optional) the target changeset (can be a partial/full changeset id or
     *                               qualified/unqualified ref name)
     * @param string $fromRepo       (optional) an optional parameter specifying the source repository containing the
     *                               source changeset                  if that changeset is not present in the current
     *                               repository; the repository can be specified                  by either its ID
     *                               <em>fromRepo=42</em> or by its project key plus its repo slug separated by
     *                               a slash: <em>fromRepo=projectKey/repoSlug</em>
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamChangesets(
        $projectKey,
        $repositorySlug,
        $from = null,
        $to = null,
        $fromRepo = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/compare/commits';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'from'           => $from,
            'to'             => $to,
            'fromRepo'       => $fromRepo,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Create a new project.
     * <p>
     * To include a custom avatar for the project, the project definition should contain an additional
     * attribute with
     * the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The URI
     * should be in
     * the following format:
     * <pre>
     * data:(content type, e.g. image/png);base64,(data)
     * </pre>
     * If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is
     * otherwise invalid,
     * <em>project creation will fail</em>.
     * <p>
     * The authenticated user must have <strong>PROJECT_CREATE</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createProject(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of projects.
     * <p>
     * Only projects for which the authenticated user has the <strong>PROJECT_VIEW</strong> permission
     * will be returned.
     *
     * @param string $name       (optional) TODO: type description here
     * @param string $permission (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProjects(
        $name = null,
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'       => $name,
            'permission' => $permission,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Delete the project matching the supplied <strong>projectKey</strong>.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project to call this
     * resource.
     *
     * @param string $projectKey TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteProject(
        $projectKey
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the project matching the <strong>projectKey</strong> supplied in the resource path.
     * <p>
     * To include a custom avatar for the updated project, the project definition should contain an
     * additional attribute
     * with the key <code>avatar</code> and the value a data URI containing Base64-encoded image data. The
     * URI should be
     * in the following format:
     * <code>
     * data:(content type, e.g. image/png);base64,(data)
     * </code>
     * If the data is not Base64-encoded, or if a character set is defined in the URI, or the URI is
     * otherwise invalid,
     * <em>project creation will fail</em>.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project to call this
     * resource.
     *
     * @param object $dynamic    TODO: type description here
     * @param string $projectKey TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateProject(
        $dynamic,
        $projectKey
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the project matching the supplied <strong>projectKey</strong>.
     * <p>
     * The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project
     * to call this
     * resource.
     *
     * @param string $projectKey TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProject(
        $projectKey
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the avatar for the project matching the supplied <strong>projectKey</strong>.
     * <p>
     * The authenticated user must have <strong>PROJECT_VIEW</strong> permission for the specified project
     * to call this
     * resource.
     *
     * @param string  $projectKey TODO: type description here
     * @param integer $s          (optional) The desired size of the image. The server will return an image as close as
     *                            possible to the specified              size.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getProjectAvatar(
        $projectKey,
        $s = 0
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/avatar.png';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            's'          => (null != $s) ? $s : 0,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the avatar for the project matching the supplied <strong>projectKey</strong>.
     * <p>
     * This resource accepts POST multipart form data, containing a single image in a form-field named
     * 'avatar'.
     * <p>
     * There are configurable server limits on both the dimensions (1024x1024 pixels by default) and
     * uploaded file size
     * (1MB by default). Several different image formats are supported, but <strong>PNG</strong> and
     * <strong>JPEG</strong> are preferred due to the file size limit.
     * <p>
     * An example <a href="http://curl.haxx.se/">curl</a> request to upload an image name 'avatar.png'
     * would be:
     * <pre>
     * curl -X POST -u username:password http://example.com/rest/api/1.0/projects/STASH/avatar.png -F
     * avatar=@avatar.png
     * </pre>
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project to call this
     * resource.
     *
     * @param string $projectKey TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function uploadAvatar(
        $projectKey
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/avatar.png';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the branches matching the supplied <strong>filterText</strong> param.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $base           (optional) base branch or tag to compare each branch to (for the metadata
     *                               providers that uses that information)
     * @param bool   $details        (optional) whether to retrieve plugin-provided metadata about each branch
     * @param string $filterText     (optional) the text to match on
     * @param string $orderBy        (optional) ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last
     *                               updated)
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getBranches(
        $projectKey,
        $repositorySlug,
        $base = null,
        $details = null,
        $filterText = null,
        $orderBy = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'base'           => $base,
            'details'        => var_export($details, true),
            'filterText'     => $filterText,
            'orderBy'        => $orderBy,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Get the default branch of the repository.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getDefaultBranch(
        $projectKey,
        $repositorySlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches/default';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the default branch of a repository.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetDefaultBranch(
        $dynamic,
        $projectKey,
        $repositorySlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/branches/default';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of users that have no granted global permissions.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $filter (optional) if specified only user names containing the supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsersWithoutAnyPermission(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/users/none';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups that have been granted at least one global permission.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $filter (optional) if specified only group names containing the supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroupsWithAnyPermission(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Promote or demote a user's global permission level. Available global permissions are:
     * <ul>
     * <li>LICENSED_USER</li>
     * <li>PROJECT_CREATE</li>
     * <li>ADMIN</li>
     * <li>SYS_ADMIN</li>
     * </ul>
     * See the <a href="https://confluence.atlassian.com/display/STASH/Global+permissions">Stash
     * documentation</a> for
     * a detailed explanation of what each permission entails.
     * <p>
     * The authenticated user must have:
     * <ul>
     * <li><strong>ADMIN</strong> permission or higher; and</li>
     * <li>the permission they are attempting to grant or higher; and</li>
     * <li>greater or equal permissions than the current permission level of the group (a user may not
     * demote the
     * permission level of a group with higher permissions than them)</li>
     * </ul>
     * to call this resource. In addition, a user may not demote a group's permission level if their own
     * permission
     * level would be reduced as a result.
     *
     * @param string $permission (optional) the permission to grant
     * @param string $name       (optional) the names of the groups
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetPermissionForGroups(
        $permission = null,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'permission' => $permission,
            'name'       => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Revoke all global permissions for a group.
     * 
     * <p>
     * The authenticated user must have:
     * <ul>
     * <li><strong>ADMIN</strong> permission or higher; and</li>
     * <li>greater or equal permissions than the current permission level of the group (a user may not
     * demote the
     * permission level of a group with higher permissions than them)</li>
     * </ul>
     * to call this resource. In addition, a user may not revoke a group's permissions if their own
     * permission level
     * would be reduced as a result.
     *
     * @param string $name (optional) the name of the group
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRevokePermissionsForGroup(
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name' => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups that have no granted global permissions.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $filter (optional) if specified only group names containing the supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroupsWithoutAnyPermission(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/groups/none';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of users that have been granted at least one global permission.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $filter (optional) if specified only user names containing the supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsersWithAnyPermission(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/users';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Promote or demote the global permission level of a user. Available global permissions are:
     * <ul>
     * <li>LICENSED_USER</li>
     * <li>PROJECT_CREATE</li>
     * <li>ADMIN</li>
     * <li>SYS_ADMIN</li>
     * </ul>
     * See the <a href="https://confluence.atlassian.com/display/STASH/Global+permissions">Stash
     * documentation</a> for
     * a detailed explanation of what each permission entails.
     * <p>
     * The authenticated user must have:
     * <ul>
     * <li><strong>ADMIN</strong> permission or higher; and</li>
     * <li>the permission they are attempting to grant; and</li>
     * <li>greater or equal permissions than the current permission level of the user (a user may not
     * demote the
     * permission level of a user with higher permissions than them)</li>
     * </ul>
     * to call this resource. In addition, a user may not demote their own permission level.
     *
     * @param string $name       (optional) the names of the users
     * @param string $permission (optional) the permission to grant
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetPermissionForUsers(
        $name = null,
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/users';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'       => $name,
            'permission' => $permission,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Revoke all global permissions for a user.
     * <p>
     * The authenticated user must have:
     * <ul>
     * <li><strong>ADMIN</strong> permission or higher; and</li>
     * <li>greater or equal permissions than the current permission level of the user (a user may not
     * demote the
     * permission level of a user with higher permissions than them)</li>
     * </ul>
     * to call this resource. In addition, a user may not demote their own permission level.
     *
     * @param string $name (optional) the name of the user
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRevokePermissionsForUser(
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/permissions/users';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name' => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of group names.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission or higher to call this
     * resource.
     *
     * @param string $filter (optional) if specified only group names containing the supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroups(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Streams a diff within a pull request.
     * <p>
     * If the specified file has been copied, moved or renamed, the <code>srcPath</code> must also be
     * specified to
     * produce the correct diff.
     * <p>
     * Note: This RESTful endpoint is currently <i>not paged</i>. The server will internally apply a hard
     * cap to the
     * streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $pullRequestId  TODO: type description here
     * @param integer $contextLines   (optional) the number of context lines to include around added/removed lines in
     *                                the diff
     * @param string  $srcPath        (optional) the previous path to the file, if the file has been copied, moved or
     *                                renamed
     * @param string  $whitespace     (optional) optional whitespace flag which can be set to <code>ignore-all</code>
     * @param bool    $withComments   (optional) <code>true</code> to embed comments in the diff (the default);
     *                                otherwise, <code>false</code>                      to stream the diff without
     *                                comments
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $pullRequestId,
        $contextLines = -1,
        $srcPath = null,
        $whitespace = null,
        $withComments = true
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'srcPath'        => $srcPath,
            'whitespace'     => $whitespace,
            'withComments'   => (null != $withComments) ? var_export($withComments, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Streams a diff within a pull request.
     * <p>
     * If the specified file has been copied, moved or renamed, the <code>srcPath</code> must also be
     * specified to
     * produce the correct diff.
     * <p>
     * Note: This RESTful endpoint is currently <i>not paged</i>. The server will internally apply a hard
     * cap to the
     * streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $pullRequestId  TODO: type description here
     * @param integer $contextLines   (optional) the number of context lines to include around added/removed lines in
     *                                the diff
     * @param string  $srcPath        (optional) the previous path to the file, if the file has been copied, moved or
     *                                renamed
     * @param string  $whitespace     (optional) optional whitespace flag which can be set to <code>ignore-all</code>
     * @param bool    $withComments   (optional) <code>true</code> to embed comments in the diff (the default);
     *                                otherwise, <code>false</code>                      to stream the diff without
     *                                comments
     * @param string  $path           (optional) the path to the file which should be diffed (optional)
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $pullRequestId,
        $contextLines = -1,
        $srcPath = null,
        $whitespace = null,
        $withComments = true,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/diff/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            'path'           => $path,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'srcPath'        => $srcPath,
            'whitespace'     => $whitespace,
            'withComments'   => (null != $withComments) ? var_export($withComments, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of recently accessed repositories for the currently authenticated user.
     * <p>
     * Repositories are ordered from most recently to least recently accessed.
     * <p>
     * Only authenticated users may call this resource.
     *
     * @param string $permission (optional) (optional) if specified, it must be a valid repository permission level
     *                           name and will limit                    the resulting repository list to ones that the
     *                           requesting user has the specified permission                    level to. If not
     *                           specified, the default <code>REPO_READ</code> permission level will be assumed.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRepositoriesRecentlyAccessed(
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/profile/recent/repos';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'permission' => $permission,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve changesets for the specified pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param bool    $withCounts     (optional) if set to true, the service will add "authorCount" and "totalCount" at
     *                                the end of the page.                      "authorCount" is the number of
     *                                different authors and "totalCount" is the total number of changesets.
     * @param integer $pullRequestId  (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getCommits(
        $projectKey,
        $repositorySlug,
        $withCounts = null,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/commits';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'withCounts'     => var_export($withCounts, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the tasks associated with a pull request.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $pullRequestId  TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPullRequestTasks(
        $projectKey,
        $repositorySlug,
        $pullRequestId
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/tasks';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the total number of {@link com.atlassian.stash.task.TaskState#OPEN open} and
     * {@link com.atlassian.stash.task.TaskState#RESOLVED resolved} tasks associated with a pull request.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $pullRequestId  TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getCountPullRequestTasks(
        $projectKey,
        $repositorySlug,
        $pullRequestId
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/tasks/count';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Promote or demote a group's permission level for the specified repository. Available repository
     * permissions are:
     * <ul>
     * <li>REPO_READ</li>
     * <li>REPO_WRITE</li>
     * <li>REPO_ADMIN</li>
     * </ul>
     * See the <a href="https://confluence.atlassian.
     * com/display/STASH/Managing+permissions+for+a+repository">Stash documentation</a>
     * for a detailed explanation of what each permission entails.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource. In addition, a user may not demote a group's
     * permission level if their
     * own permission level would be reduced as a result.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $permission     (optional) the permission to grant
     * @param string $name           (optional) the names of the groups
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetPermissionForGroup(
        $projectKey,
        $repositorySlug,
        $permission = null,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'permission'     => $permission,
            'name'           => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups that have been granted at least one permission for the specified
     * repository.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $filter         (optional) if specified only group names containing the supplied string will be
     *                               returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroupsWithAnyPermission(
        $projectKey,
        $repositorySlug,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'         => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Revoke all permissions for the specified repository for a group.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource.
     * <p>
     * In addition, a user may not revoke a group's permissions if it will reduce their own permission
     * level.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $name           (optional) the name of the group
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRevokePermissionsForGroup(
        $projectKey,
        $repositorySlug,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'           => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Promote or demote a user's permission level for the specified repository. Available repository
     * permissions are:
     * <ul>
     * <li>REPO_READ</li>
     * <li>REPO_WRITE</li>
     * <li>REPO_ADMIN</li>
     * </ul>
     * See the <a href="https://confluence.atlassian.
     * com/display/STASH/Managing+permissions+for+a+repository">Stash documentation</a>
     * for a detailed explanation of what each permission entails.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource. In addition, a user may not reduce their own
     * permission level unless
     * they have a project or global permission that already implies that permission.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $name           (optional) the names of the users
     * @param string $permission     (optional) the permission to grant
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetPermissionForUser(
        $projectKey,
        $repositorySlug,
        $name = null,
        $permission = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'           => $name,
            'permission'     => $permission,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of users that have been granted at least one permission for the specified repository.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $filter         (optional) if specified only group names containing the supplied string will be
     *                               returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsersWithAnyPermission(
        $projectKey,
        $repositorySlug,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'         => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Revoke all permissions for the specified repository for a user.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource.
     * <p>
     * In addition, a user may not revoke their own repository permissions if they do not have a higher
     * project or global permission.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $name           (optional) the name of the user
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRevokePermissionsForUser(
        $projectKey,
        $repositorySlug,
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'           => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups that have no granted permissions for the specified repository.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $filter         (optional) if specified only group names containing the supplied string will be
     *                               returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroupsWithoutAnyPermission(
        $projectKey,
        $repositorySlug,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/groups/none';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'         => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of <i>licensed</i> users that have no granted permissions for the specified
     * repository.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository or a higher
     * project or global permission to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $filter         (optional) if specified only group names containing the supplied string will be
     *                               returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsersWithoutPermission(
        $projectKey,
        $repositorySlug,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/permissions/users/none';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter'         => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of commits from a given starting commit or "between" two commits. If no explicit
     * commit is
     * specified, the tip of the repository's default branch is assumed. commits may be identified by
     * branch or tag
     * name or by ID. A path may be supplied to restrict the returned commits to only those which affect
     * that path.
     * <p>
     * The authenticated user must have <b>REPO_READ</b> permission for the specified repository to call
     * this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $path           (optional) an optional path to filter commits by
     * @param string $since          (optional) the commit ID or ref (exclusively) to retrieve commits after
     * @param string $until          (optional) the commit ID (SHA1) or ref (inclusively) to retrieve commits before
     * @param bool   $withCounts     (optional) optionally include the total number of commits and total number of
     *                               unique authors
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getCommits(
        $projectKey,
        $repositorySlug,
        $path = null,
        $since = null,
        $until = null,
        $withCounts = false
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'           => $path,
            'since'          => $since,
            'until'          => $until,
            'withCounts'     => (null != $withCounts) ? var_export($withCounts, true) : false,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a single commit <i>identified by its ID</i>>. In general, that ID is a SHA1. <u>From 2.11,
     * ref names
     * like "refs/heads/master" are no longer accepted by this resource.</u>
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $path           (optional) an optional path to filter the commit by. If supplied the details
     *                               returned <i>may not</i>              be for the specified commit. Instead,
     *                               starting from the specified commit, they will be the              details for the
     *                               first commit affecting the specified path.
     * @param string $commitId       (optional) the commit ID to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getCommit(
        $projectKey,
        $repositorySlug,
        $path = null,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'           => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the tags matching the supplied <strong>filterText</strong> param.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the context repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $filterText     (optional) the text to match on
     * @param string $orderBy        (optional) ordering of refs either ALPHABETICAL (by name) or MODIFICATION (last
     *                               updated)
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getTags(
        $projectKey,
        $repositorySlug,
        $filterText = null,
        $orderBy = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/tags';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filterText'     => $filterText,
            'orderBy'        => $orderBy,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Add a new comment.
     * <p>
     * Comments can be added in a few places by setting different attributes:
     * <p>
     * General pull request comment:
     * 
     * <pre>
     * {
     * "text": "An insightful general comment on a pull request."
     * }
     * </pre>
     * 
     * Reply to a comment:
     * 
     * <pre>
     * {
     * "text": "A measured reply.",
     * "parent": {
     * "id": 1
     * }
     * }
     * </pre>
     * 
     * General file comment:
     * 
     * <pre>
     * {
     * "text": "An insightful general comment on a file.",
     * "anchor": {
     * "path": "path/to/file",
     * "srcPath": "path/to/file"
     * }
     * }
     * </pre>
     * 
     * File line comment:
     * 
     * <pre>
     * {
     * "text": "A pithy comment on a particular line within a file.",
     * "anchor": {
     * "line": 1,
     * "lineType": "CONTEXT",
     * "fileType": "FROM"
     * "path": "path/to/file",
     * "srcPath": "path/to/file"
     * }
     * }
     * </pre>
     * <strong>Note: general file comments are an experimental feature and may change in the near future!
     * </strong>
     * <p>
     * For file and line comments, 'path' refers to the path of the file to which the comment should be
     * applied and
     * 'srcPath' refers to the path the that file used to have (only required for copies and moves).
     * <p>
     * For line comments, 'line' refers to the line in the diff that the comment should apply to.
     * 'lineType' refers to
     * the type of diff hunk, which can be:
     * <ul>
     * <li>'ADDED' - for an added line;</li>
     * <li>'REMOVED' - for a removed line; or</li>
     * <li>'CONTEXT' - for a line that was unmodified but is in the vicinity of the diff.</li>
     * </ul>
     * 'fileType' refers to the file of the diff to which the anchor should be attached - which is of
     * relevance when
     * displaying the diff in a side-by-side way. Currently the supported values are:
     * <ul>
     * <li>'FROM' - the source file of the diff</li>
     * <li>'TO' - the destination file of the diff</li>
     * </ul>
     * If the current user is not a participant the user is added as a watcher of the pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param object  $dynamic        TODO: type description here
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createComment(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $path           (optional) TODO: type description here
     * @param integer $pullRequestId  (optional) TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getComments(
        $projectKey,
        $repositorySlug,
        $path = null,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'           => $path,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the text of a comment. Only the user who created a comment may update it.
     * <p>
     * <strong>Note:</strong> the supplied supplied JSON object must contain a <code>version</code> that
     * must match the
     * server's version of the comment or the update will fail. To determine the current version of
     * the comment, the comment should be fetched from the server prior to the update. Look for the
     * 'version' attribute in the returned JSON structure.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param object  $dynamic        TODO: type description here
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @param integer $commentId      (optional) the id of the comment to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateComment(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $pullRequestId = null,
        $commentId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            'commentId'      => $commentId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Delete a pull request comment. Anyone can delete their own comment. Only users with
     * <strong>REPO_ADMIN</strong>
     * and above may delete comments created by other users.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $version        (optional) The expected version of the comment. This must match the server's
     *                                version of the comment or                       the delete will fail. To
     *                                determine the current version of the comment, the comment should be
     *                                fetched from the server prior to the delete. Look for the 'version'
     *                                attribute in the                       returned JSON structure.
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @param integer $commentId      (optional) the id of the comment to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteComment(
        $projectKey,
        $repositorySlug,
        $version = -1,
        $pullRequestId = null,
        $commentId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            'commentId'      => $commentId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'version'        => (null != $version) ? $version : -1,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a pull request comment.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @param integer $commentId      (optional) the id of the comment to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getComment(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null,
        $commentId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/comments/{commentId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            'commentId'      => $commentId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve version information and other application properties.
     * <p>
     * No authentication is required to call this resource.
     *
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getApplicationProperties()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/application-properties';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of repositories based on query parameters that control the search. See the
     * documentation of the
     * parameters for more details.
     * <p>
     * This resource is anonymously accessible.
     * <p>
     * <b>Note on permissions.</b> In absence of the {@code permission} query parameter the implicit
     * 'read' permission
     * is assumed. Please note that this permission is lower than the REPO_READ permission rather than
     * being equal to
     * it. The implicit 'read' permission for a given repository is assigned to any user that has any of
     * the higher
     * permissions, such as <tt>REPO_READ</tt>, as well as to anonymous users if the repository is marked
     * as public.
     * The important implication of the above is that an anonymous request to this resource with a
     * permission level
     * <tt>REPO_READ</tt> is guaranteed to receive an empty list of repositories as a result. For
     * anonymous requests
     * it is therefore recommended to not specify the <tt>permission</tt> parameter at all.
     *
     * @param string $name        (optional) (optional) if specified, this will limit the resulting repository list to
     *                            ones whose name                     matches this parameter's value. The match will be
     *                            done case-insensitive and any leading                     and/or trailing whitespace
     *                            characters on the <code>name</code> parameter will be stripped.
     * @param string $projectname (optional) (optional) if specified, this will limit the resulting repository list to
     *                            ones whose project's                     name matches this parameter's value. The
     *                            match will be done case-insensitive and any leading                     and/or
     *                            trailing whitespace characters on the <code>projectname</code> parameter will
     *                            be stripped.
     * @param string $permission  (optional) (optional) if specified, it must be a valid repository permission level
     *                            name and will limit                     the resulting repository list to ones that
     *                            the requesting user has the specified permission                     level to. If not
     *                            specified, the default implicit 'read' permission level will be assumed. The
     *                            currently supported explicit permission values are <tt>REPO_READ</tt>,
     *                            <tt>REPO_WRITE</tt>                     and <tt>REPO_ADMIN</tt>.
     * @param string $visibility  (optional) (optional) if specified, this will limit the resulting repository list
     *                            based on the                     repositories visibility. Valid values are
     *                            <em>public</em> or <em>private</em>.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRepositories(
        $name = null,
        $projectname = null,
        $permission = null,
        $visibility = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/repos';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'        => $name,
            'projectname' => $projectname,
            'permission'  => $permission,
            'visibility'  => $visibility,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Gets changes for the specified PullRequest.
     * <p>
     * Note: This resource is currently <i>not paged</i>. The server will return at most one page. The
     * server will
     * truncate the number of changes to either the request's page limit or an internal maximum, whichever
     * is smaller.
     * The start parameter of the page request is also ignored.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $pullRequestId  TODO: type description here
     * @param bool   $withComments   (optional) {@code true} to apply comment counts in the changes (the default);
     *                               otherwise, {@code false}                      to stream changes without comment
     *                               counts
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamChanges(
        $projectKey,
        $repositorySlug,
        $pullRequestId,
        $withComments = true
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/changes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'withComments'   => (null != $withComments) ? var_export($withComments, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of users.
     * <p>
     * The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this
     * resource.
     *
     * @param string $filter (optional) if specified only users with usernames, display name or email addresses
     *                       containing the supplied                string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsers(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Creates a new user from the assembled query parameters.
     * <p>
     * The default group can be used to control initial permissions for new users, such as granting users
     * the ability
     * to login or providing read access to certain projects or repositories. If the user is not added to
     * the default
     * group, they may not be able to login after their account is created until explicit permissions are
     * configured.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param string $name              (optional) the username for the new user
     * @param string $password          (optional) the password for the new user
     * @param string $displayName       (optional) the display name for the new user
     * @param string $emailAddress      (optional) the e-mail address for the new user
     * @param bool   $addToDefaultGroup (optional) <code>true</code> to add the user to the default group, which can be
     *                                  used to grant them                           a set of initial permissions;
     *                                  otherwise, <code>false</code> to not add them to a group
     * @param string $notify            (optional) if present and not <code>false</code> instead of requiring a
     *                                  password,                           the create user will be notified via email
     *                                  their account has been created and requires                           a
     *                                  password to be reset. This option can only be used if a mail server has been
     *                                  configured
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createUser(
        $name = null,
        $password = null,
        $displayName = null,
        $emailAddress = null,
        $addToDefaultGroup = true,
        $notify = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name'              => $name,
            'password'          => $password,
            'displayName'       => $displayName,
            'emailAddress'      => $emailAddress,
            'addToDefaultGroup' => (null != $addToDefaultGroup) ? var_export($addToDefaultGroup, true) : true,
            'notify'            => $notify,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'      => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Deletes the specified user, removing them from the system. This also removes any permissions that
     * may have been
     * granted to the user.
     * <p>
     * A user may not delete themselves, and a user with <strong>ADMIN</strong> permissions may not delete
     * a user with
     * <strong>SYS_ADMIN</strong>permissions.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param string $name (optional) the username identifying the user to delete
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteUser(
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name' => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update a user's details.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateUserDetails(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Rename a user.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRenameUser(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/rename';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Clears any CAPTCHA challenge that may constrain the user with the supplied username when they
     * authenticate.
     * Additionally any counter or metric that contributed towards the user being issued the CAPTCHA
     * challenge
     * (for instance too many consecutive failed logins) will also be reset.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource, and
     * may not clear
     * the CAPTCHA of a user with greater permissions than themselves.
     *
     * @param string $name (optional) TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteClearUserCaptchaChallenge(
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/captcha';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name' => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Deletes the specified group, removing them from the system. This also removes any permissions that
     * may have been
     * granted to the group.
     * <p>
     * A user may not delete the last group that is granting them administrative permissions, or a group
     * with greater
     * permissions than themselves.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param string $name (optional) the name identifying the group to delete
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteGroup(
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name' => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Create a new group.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $name (optional) Name of the group.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createGroup(
        $name = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'name' => $name,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of groups.
     * <p>
     * The authenticated user must have <strong>LICENSED_USER</strong> permission or higher to call this
     * resource.
     *
     * @param string $filter (optional) if specified only group names containing the supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getGroups1(
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'filter' => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * <p><strong>Deprecated since 2.10 for removal in 4.0</strong>. Use {@code /rest/users/add-groups}
     * instead.</p>
     * 
     * Add a user to a group.
     * <p>
     * In the request entity, the <em>context</em> attribute is the group and the <em>itemName</em> is the
     * user.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addUserToGroup(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups/add-user';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * <p><strong>Deprecated since 2.10 for removal in 4.0</strong>. Use {@code /rest/users/add-groups}
     * instead.</p>
     * 
     * Add a user to a group. This is very similar to <code>groups/add-user</code>, but with the
     * <em>context</em> and
     * <em>itemName</em> attributes of the supplied request entity reversed. On the face of it this may
     * appear
     * redundant, but it facilitates a specific UI component in Stash.
     * <p>
     * In the request entity, the <em>context</em> attribute is the user and the <em>itemName</em> is the
     * group.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addGroupToUser(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/add-group';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Add multiple users to a group.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addUsersToGroup(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups/add-users';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Add a user to one or more groups.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function addUserToGroups(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/add-groups';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * <p><strong>Deprecated since 2.10 for removal in 3.0</strong>. Use {@code /rest/users/remove-groups}
     * instead.</p>
     * 
     * Remove a user from a group.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     * <p>
     * In the request entity, the <em>context</em> attribute is the group and the <em>itemName</em> is the
     * user.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRemoveUserFromGroup(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups/remove-user';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Remove a user from a group. This is very similar to <code>groups/remove-user</code>, but with the
     * <em>context</em>
     * and <em>itemName</em> attributes of the supplied request entity reversed. On the face of it this
     * may appear
     * redundant, but it facilitates a specific UI component in Stash.
     * <p>
     * In the request entity, the <em>context</em> attribute is the user and the <em>itemName</em> is the
     * group.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRemoveGroupFromUser(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/remove-group';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a list of users that are members of a specified group.
     * <p>
     * The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this
     * resource.
     *
     * @param string $context (optional) the group which should be used to locate members
     * @param string $filter  (optional) if specified only users with usernames, display names or email addresses
     *                        containing the                   supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findUsersInGroup(
        $context = null,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups/more-members';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'context' => $context,
            'filter'  => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a list of users that are <em>not</em> members of a specified group.
     * <p>
     * The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this
     * resource.
     *
     * @param string $context (optional) the group which should be used to locate non-members
     * @param string $filter  (optional) if specified only users with usernames, display names or email addresses
     *                        containing the                   supplied string will be returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findUsersNotInGroup(
        $context = null,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/groups/more-non-members';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'context' => $context,
            'filter'  => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a list of groups the specified user is a member of.
     * <p>
     * The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this
     * resource.
     *
     * @param string $context (optional) the user which should be used to locate groups
     * @param string $filter  (optional) if specified only groups with names containing the supplied string will be
     *                        returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findGroupsForUser(
        $context = null,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/more-members';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'context' => $context,
            'filter'  => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a list of groups the specified user is <em>not</em> a member of.
     * <p>
     * The authenticated user must have the <strong>LICENSED_USER</strong> permission to call this
     * resource.
     *
     * @param string $context (optional) the user which should be used to locate groups
     * @param string $filter  (optional) if specified only groups with names containing the supplied string will be
     *                        returned
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function findOtherGroupsForUser(
        $context = null,
        $filter = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/more-non-members';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'context' => $context,
            'filter'  => $filter,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update a user's password.
     * <p>
     * The authenticated user must have the <strong>ADMIN</strong> permission to call this resource, and
     * may not update
     * the password of a user with greater permissions than themselves.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateUserPassword(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/admin/users/credentials';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of files from particular directory of a repository. The search is done recursively,
     * so all files
     * from any sub-directory of the specified directory will be returned.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $at             (optional) the changeset id or ref (e.g. a branch or tag) to list the files at.
     *                               If not specified the default branch will be used instead.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listRepositoryFiles(
        $projectKey,
        $repositorySlug,
        $at = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/files';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'at'             => $at,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of files from particular directory of a repository. The search is done recursively,
     * so all files
     * from any sub-directory of the specified directory will be returned.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $at             (optional) the changeset id or ref (e.g. a branch or tag) to list the files at.
     *                               If not specified the default branch will be used instead.
     * @param string $path           (optional) the directory to list files for.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listRepositoryFiles(
        $projectKey,
        $repositorySlug,
        $at = null,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/files/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'path'           => $path,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'at'             => $at,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the current log level for the root logger.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRootLevel()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/logs/rootLogger';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Set the current log level for the root logger.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $levelName (optional) the level to set the logger to. Either TRACE, DEBUG, INFO, WARN or ERROR
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetRootLevel(
        $levelName = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/logs/rootLogger/{levelName}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'levelName' => $levelName,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the current log level for a given logger.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $loggerName (optional) the name of the logger.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getLevel(
        $loggerName = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/logs/logger/{loggerName}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'loggerName' => $loggerName,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Set the current log level for a given logger.
     * <p>
     * The authenticated user must have <strong>ADMIN</strong> permission or higher to call this resource.
     *
     * @param string $levelName  (optional) the level to set the logger to. Either TRACE, DEBUG, INFO, WARN or ERROR
     * @param string $loggerName (optional) the name of the logger.
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetLevel(
        $levelName = null,
        $loggerName = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/logs/logger/{loggerName}/{levelName}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'levelName'  => $levelName,
            'loggerName' => $loggerName,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of users, optionally run through provided filters.
     * <p>
     * Only authenticated users may call this resource.
     * 
     * <h3>Supported Filters</h3>
     * <p>
     * Filters are provided in query parameters in a standard <code>name=value</code> fashion. The
     * following filters are
     * currently supported:
     * <ul>
     * <li>
     * {@code filter} - return only users, whose username, name or email address <i>contain</i>
     * the
     * {@code filter} value
     * </li>
     * <li>
     * {@code permission} - the "root" of a permission filter, whose value must be a valid global,
     * project, or repository permission. Additional filter parameters referring to this filter
     * that specify the
     * resource (project or repository) to apply the filter to must be prefixed with
     * <code>permission.</code>. See the
     * section "Permission Filters" below for more details.
     * </li>
     * <li>
     * {@code permission.N} - the "root" of a single permission filter, similar to the {@code
     * permission}
     * parameter, where "N" is a natural number starting from 1. This allows clients to specify
     * multiple permission
     * filters, by providing consecutive filters as {@code permission.1}, {@code permission.2} etc.
     * Note that
     * the filters numbering has to start with 1 and be continuous for all filters to be processed.
     * The total allowed
     * number of permission filters is 50 and all filters exceeding that limit will be dropped.
     * See the section
     * "Permission Filters" below for more details on how the permission filters are processed.
     * </li>
     * </ul>
     * 
     * 
     * <h3>Permission Filters</h3>
     * <p>
     * The following three sub-sections list parameters supported for permission filters (where
     * <code>[root]</code> is
     * the root permission filter name, e.g. {@code permission}, {@code permission.1} etc.) depending on
     * the
     * permission resource. The system determines which filter to apply (Global, Project or Repository
     * permission)
     * based on the <code>[root]</code> permission value. E.g. {@code ADMIN} is a global permission,
     * {@code PROJECT_ADMIN} is a project permission and {@code REPO_ADMIN} is a repository permission.
     * Note
     * that the parameters for a given resource will be looked up in the order as they are listed below,
     * that is e.g.
     * for a project resource, if both {@code projectId} and {@code projectKey} are provided, the system
     * will
     * use {@code projectId} for the lookup.
     * <h4>Global permissions</h4>
     * <p>
     * The permission value under <code>[root]</code> is the only required and recognized parameter, as
     * global
     * permissions do not apply to a specific resource.
     * <p>
     * Example valid filter: <code>permission=ADMIN</code>.
     * <h4>Project permissions</h4>
     * <ul>
     * <li><code>[root]</code>- specifies the project permission</li>
     * <li><code>[root].projectId</code> - specifies the project ID to lookup the project by</li>
     * <li><code>[root].projectKey</code> - specifies the project key to lookup the project by</li>
     * </ul>
     * <p>
     * Example valid filter: <code>permission.1=PROJECT_ADMIN&permission.1.projectKey=TEST_PROJECT</code>.
     * <h4>Repository permissions</h4>
     * <ul>
     * <li><code>[root]</code>- specifies the repository permission</li>
     * <li><code>[root].projectId</code> - specifies the repository ID to lookup the repository
     * by</li>
     * <li><code>[root].projectKey</code> and <code>[root].repositorySlug</code>- specifies the
     * project key and
     * repository slug to lookup the repository by; both values <i>need to</i> be provided for this
     * look up to be
     * triggered</li>
     * </ul>
     * Example valid filter: <code>permission.2=REPO_ADMIN&permission.2.projectKey=TEST_PROJECT&permission.
     * 2.repositorySlug=test_repo</code>.
     *
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUsers()
    {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the currently authenticated user's details. Note that <em>the name attribute is ignored</em>,
     * the update
     * will always be applied to the currently authenticated user.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateUserDetails1(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Delete the avatar associated to a user.
     * <p>
     * Users are always allowed to delete their own avatar. To delete someone else's avatar the
     * authenticated user must
     * have global <strong>ADMIN</strong> permission, or global <strong>SYS_ADMIN</strong> permission to
     * update a
     * <strong>SYS_ADMIN</strong> user's avatar.
     *
     * @param string $userSlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteAvatar(
        $userSlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users/{userSlug}/avatar.png';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'userSlug' => $userSlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the avatar for the user with the supplied <strong>slug</strong>.
     * <p>
     * This resource accepts POST multipart form data, containing a single image in a form-field named
     * 'avatar'.
     * <p>
     * There are configurable server limits on both the dimensions (1024x1024 pixels by default) and
     * uploaded
     * file size (1MB by default). Several different image formats are supported, but <strong>PNG</strong>
     * and
     * <strong>JPEG</strong> are preferred due to the file size limit.
     * <p>
     * This resource has Cross-Site Request Forgery (XSRF) protection. To allow the request to
     * pass the XSRF check the caller needs to send an <code>X-Atlassian-Token</code> HTTP header with
     * the
     * value <code>no-check</code>.
     * <p>
     * An example <a href="http://curl.haxx.se/">curl</a> request to upload an image name 'avatar.png'
     * would be:
     * <pre>
     * curl -X POST -u username:password -H "X-Atlassian-Token: no-check" http://example.
     * com/rest/api/latest/users/jdoe/avatar.png -F avatar=@avatar.png
     * </pre>
     * <p>
     * Users are always allowed to update their own avatar. To update someone else's avatar the
     * authenticated user must
     * have global <strong>ADMIN</strong> permission, or global <strong>SYS_ADMIN</strong> permission to
     * update a
     * <strong>SYS_ADMIN</strong> user's avatar.
     *
     * @param string $userSlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function uploadAvatar(
        $userSlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users/{userSlug}/avatar.png';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'userSlug' => $userSlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the user matching the supplied <strong>userSlug</strong>.
     * <p>
     *
     * @param string $userSlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUser(
        $userSlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users/{userSlug}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'userSlug' => $userSlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the currently authenticated user's password.
     *
     * @param object $dynamic TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateUserPassword1(
        $dynamic
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users/credentials';

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve repositories from the project corresponding to the supplied <strong>projectKey</strong>.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified project to
     * call this
     * resource.
     *
     * @param string $projectKey (optional) the parent project key
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRepositories(
        $projectKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Create a new repository. Requires an existing project in which this repository will be created.
     * The only parameters which will be used are name and scmId.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the context project
     * to call this
     * resource.
     *
     * @param object $dynamic    TODO: type description here
     * @param string $projectKey (optional) the parent project key
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRepository(
        $dynamic,
        $projectKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey' => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Schedule the repository matching the supplied <strong>projectKey</strong> and
     * <strong>repositorySlug</strong> to
     * be deleted. If the request repository is not present
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param string $repositorySlug (optional) the repository slug
     * @param string $projectKey     (optional) the parent project key
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteRepository(
        $repositorySlug = null,
        $projectKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'repositorySlug' => $repositorySlug,
            'projectKey'     => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Create a new repository forked from an existing repository.
     * <p>
     * The JSON body for this {@code POST} is not required to contain <i>any</i> properties. Even the name
     * may be
     * omitted. The following properties will be used, if provided:
     * <ul>
     * <li>{@code "name":"Fork name"} - Specifies the forked repository's name
     * <ul>
     * <li>Defaults to the name of the origin repository if not specified</li>
     * </ul>
     * </li>
     * <li>{@code "project":{"key":"TARGET_KEY"}} - Specifies the forked repository's target project
     * by key
     * <ul>
     * <li>Defaults to the current user's personal project if not specified</li>
     * </ul>
     * </li>
     * </ul>
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * and
     * <strong>PROJECT_ADMIN</strong> on the target project to call this resource. Note that users
     * <i>always</i>
     * have <b>PROJECT_ADMIN</b> permission on their personal projects.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $repositorySlug (optional) the repository slug
     * @param string $projectKey     (optional) the parent project key
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createForkRepository(
        $dynamic,
        $repositorySlug = null,
        $projectKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'repositorySlug' => $repositorySlug,
            'projectKey'     => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the repository matching the supplied <strong>projectKey</strong> and
     * <strong>repositorySlug</strong>.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $repositorySlug (optional) the repository slug
     * @param string $projectKey     (optional) the parent project key
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRepository(
        $repositorySlug = null,
        $projectKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'repositorySlug' => $repositorySlug,
            'projectKey'     => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the repository matching the <strong>repositorySlug</strong> supplied in the resource path.
     * <p>
     * The repository's slug is derived from its name. If the name changes the slug may also change.
     * <p>
     * This API can be used to move the repository to a different project by setting the new project in
     * the request,
     * example: {@code {"project":{"key":"NEW_KEY"}}} .
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $repositorySlug (optional) the repository slug
     * @param string $projectKey     (optional) the parent project key
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateRepository(
        $dynamic,
        $repositorySlug = null,
        $projectKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'repositorySlug' => $repositorySlug,
            'projectKey'     => $projectKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve repositories which have been forked from this one. Unlike {@link
     * #getRelatedRepositories(Repository,
     * PageRequest) related repositories}, this only looks at a given repository's direct forks. If those
     * forks have
     * themselves been the origin of more forks, such "grandchildren" repositories will not be retrieved.
     * <p>
     * Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included,
     * even
     * if other repositories have been forked from this one.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getForkedRepositories(
        $projectKey,
        $repositorySlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/forks';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve repositories which are related to this one. Related repositories are from the same
     * {@link Repository#getHierarchyId() hierarchy} as this repository.
     * <p>
     * Only repositories to which the authenticated user has <b>REPO_READ</b> permission will be included,
     * even
     * if more repositories are part of this repository's hierarchy.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRelatedRepositories(
        $projectKey,
        $repositorySlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/related';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * If a create or fork operation fails, calling this method will clean up the broken repository and try
     * again. The
     * repository must be in an INITIALISATION_FAILED state.
     * <p>
     * The authenticated user must have <strong>PROJECT_ADMIN</strong> permission for the specified
     * project to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createRetryCreateRepository(
        $projectKey,
        $repositorySlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/recreate';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the diff for a specified file path between two provided revisions.
     * <p>
     * <strong>Note:</strong> This resource is currently <i>not paged</i>. The server will internally
     * apply a hard cap
     * to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.
     * In the event
     * that the cap is reached, the diff will be cut short and one or more <code>truncated</code> flags
     * will be set to
     * <code>true</code> on the segments, hunks and diffs substructures in the returned JSON response.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $contextLines   (optional) the number of context lines to include around added/removed lines in
     *                                the diff
     * @param string  $since          (optional) the base revision to diff from. If omitted the parent revision of the
     *                                until revision is used
     * @param string  $srcPath        (optional) the source path for the file, if it was copied, moved or renamed
     * @param string  $until          (optional) the target revision to diff to (required)
     * @param string  $whitespace     (optional) optional whitespace flag which can be set to <code>ignore-all</code>
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $contextLines = -1,
        $since = null,
        $srcPath = null,
        $until = null,
        $whitespace = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/diff';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'since'          => $since,
            'srcPath'        => $srcPath,
            'until'          => $until,
            'whitespace'     => $whitespace,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the diff for a specified file path between two provided revisions.
     * <p>
     * <strong>Note:</strong> This resource is currently <i>not paged</i>. The server will internally
     * apply a hard cap
     * to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.
     * In the event
     * that the cap is reached, the diff will be cut short and one or more <code>truncated</code> flags
     * will be set to
     * <code>true</code> on the segments, hunks and diffs substructures in the returned JSON response.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $contextLines   (optional) the number of context lines to include around added/removed lines in
     *                                the diff
     * @param string  $since          (optional) the base revision to diff from. If omitted the parent revision of the
     *                                until revision is used
     * @param string  $srcPath        (optional) the source path for the file, if it was copied, moved or renamed
     * @param string  $until          (optional) the target revision to diff to (required)
     * @param string  $whitespace     (optional) optional whitespace flag which can be set to <code>ignore-all</code>
     * @param string  $path           (optional) the path to the file which should be diffed (required)
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $contextLines = -1,
        $since = null,
        $srcPath = null,
        $until = null,
        $whitespace = null,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/diff/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'path'           => $path,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'since'          => $since,
            'srcPath'        => $srcPath,
            'until'          => $until,
            'whitespace'     => $whitespace,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of content for a file path at a specified revision.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $at             (optional) the changeset id or ref to retrieve the content for.
     * @param bool   $type           (optional) if true only the type will be returned for the file path instead of the
     *                               contents.
     * @param string $blame          (optional) if present the blame will be returned for the file as well.
     * @param string $noContent      (optional) if present and used with blame only the blame is retrieved instead of
     *                               the contents.
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getContent(
        $projectKey,
        $repositorySlug,
        $at = null,
        $type = false,
        $blame = null,
        $noContent = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/browse';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'at'             => $at,
            'type'           => (null != $type) ? var_export($type, true) : false,
            'blame'          => $blame,
            'noContent'      => $noContent,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of content for a file path at a specified revision.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $at             (optional) the changeset id or ref to retrieve the content for.
     * @param bool   $type           (optional) if true only the type will be returned for the file path instead of the
     *                               contents.
     * @param string $blame          (optional) if present the blame will be returned for the file as well.
     * @param string $noContent      (optional) if present and used with blame only the blame is retrieved instead of
     *                               the contents.
     * @param string $path           (optional) the file path to retrieve content from
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getContent(
        $projectKey,
        $repositorySlug,
        $at = null,
        $type = false,
        $blame = null,
        $noContent = null,
        $path = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/browse/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'path'           => $path,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'at'             => $at,
            'type'           => (null != $type) ? var_export($type, true) : false,
            'blame'          => $blame,
            'noContent'      => $noContent,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Preview the generated html for given markdown contents.
     * <p>
     * Only authenticated users may call this resource.
     *
     * @param object $dynamic    TODO: type description here
     * @param string $urlMode    (optional) TODO: type description here
     * @param bool   $hardwrap   (optional) TODO: type description here
     * @param bool   $htmlEscape (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createPreview(
        $dynamic,
        $urlMode = null,
        $hardwrap = null,
        $htmlEscape = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/markup/preview';

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'urlMode'    => $urlMode,
            'hardwrap'   => var_export($hardwrap, true),
            'htmlEscape' => var_export($htmlEscape, true),
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of pull requests to or from the specified repository.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call
     * this resource.
     * 
     * Optionally clients can specify PR participant filters. Each filter has a mandatory {@code username.
     * N}
     * parameter, and the optional {@code role.N} and {@code approved.N} parameters.
     * <ul>
     * <li>
     * {@code username.N} - the "root" of a single participant filter, where "N" is a natural
     * number
     * starting from 1. This allows clients to specify multiple participant filters, by providing
     * consecutive
     * filters as {@code username.1}, {@code username.2} etc. Note that the filters numbering has
     * to start
     * with 1 and be continuous for all filters to be processed. The total allowed number of
     * participant
     * filters is 10 and all filters exceeding that limit will be dropped.
     * </li>
     * <li>
     * {@code role.N}(optional) the role associated with {@code username.N}.
     * This must be one of {@code AUTHOR}, {@code REVIEWER}, or{@code PARTICIPANT}
     * </li>
     * <li>
     * {@code approved.N}(optional) the approved status associated with {@code username.N}.
     * That is whether {@code username.N} has approved the PR. Either {@code true}, or {@code
     * false}
     * </li>
     * </ul>
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $direction      (optional) (optional, defaults to <strong>INCOMING</strong>) the direction
     *                               relative to the specified                   repository. Either
     *                               <strong>INCOMING</strong> or <strong>OUTGOING</strong>.
     * @param string $at             (optional) (optional) a <i>fully-qualified</i> branch ID to find pull requests to
     *                               or from,            such as {@code refs/heads/master}
     * @param string $state          (optional) (optional, defaults to <strong>OPEN</strong>). Supply
     *                               <strong>ALL</strong> to return pull request                in any state. If a
     *                               state is supplied only pull requests in the specified state will be returned.
     *                               Either <strong>OPEN</strong>, <strong>DECLINED</strong> or
     *                               <strong>MERGED</strong>.
     * @param string $order          (optional) (optional) the order to return pull requests in, either
     *                               <strong>OLDEST</strong> (as in: "oldest               first") or
     *                               <strong>NEWEST</strong>.
     * @param bool   $withAttributes (optional) (optional) defaults to true, whether to return additional pull request
     *                               attributes
     * @param bool   $withProperties (optional) (optional) defaults to true, whether to return additional pull request
     *                               properties
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getPage(
        $projectKey,
        $repositorySlug,
        $direction = 'incoming',
        $at = null,
        $state = null,
        $order = null,
        $withAttributes = true,
        $withProperties = true
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'direction'      => (null != $direction) ? $direction : 'incoming',
            'at'             => $at,
            'state'          => $state,
            'order'          => $order,
            'withAttributes' => (null != $withAttributes) ? var_export($withAttributes, true) : true,
            'withProperties' => (null != $withProperties) ? var_export($withProperties, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Create a new pull request between two branches. The branches may be in the same repository, or
     * different ones.
     * When using different repositories, they must still be in the same {@link
     * Repository#getHierarchyId() hierarchy}.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the "from" and
     * "to"repositories to
     * call this resource.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function create(
        $dynamic,
        $projectKey,
        $repositorySlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Decline a pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $version        (optional) the current version of the pull request. If the server's version isn't
     *                                the same as the specified                 version the operation will fail. To
     *                                determine the current version of the pull request it should be
     *                                fetched from the server prior to this operation. Look for the 'version' attribute
     *                                in the returned                 JSON structure.
     * @param integer $pullRequestId  (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createDecline(
        $projectKey,
        $repositorySlug,
        $version = -1,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/decline';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'version'        => (null != $version) ? $version : -1,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of activity associated with a pull request.
     * <p>
     * Activity items include comments, approvals, rescopes (i.e. adding and removing of commits), merges
     * and more.
     * <p>
     * Different types of activity items may be introduced in newer versions of Stash or by user installed
     * plugins, so
     * clients should be flexible enough to handle unexpected entity shapes in the returned page.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $fromId         (optional) (optional) the id of the activity item to use as the first item in the
     *                                returned page
     * @param string  $fromType       (optional) (required if <strong>fromId</strong> is present) the type of the
     *                                activity item specified by                  <strong>fromId</strong> (either
     *                                <strong>COMMENT</strong> or <strong>ACTIVITY</strong>)
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getActivities(
        $projectKey,
        $repositorySlug,
        $fromId = null,
        $fromType = null,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/activities';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'fromId'         => $fromId,
            'fromType'       => $fromType,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Re-open a declined pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $version        (optional) the current version of the pull request. If the server's version isn't
     *                                the same as the specified                 version the operation will fail. To
     *                                determine the current version of the pull request it should be
     *                                fetched from the server prior to this operation. Look for the 'version' attribute
     *                                in the returned                 JSON structure.
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createReopen(
        $projectKey,
        $repositorySlug,
        $version = -1,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/reopen';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'version'        => (null != $version) ? $version : -1,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Test whether a pull request can be merged.
     * <p>
     * A pull request may not be merged if:
     * <ul>
     * <li>there are conflicts that need to be manually resolved before merging; and/or</li>
     * <li>one or more merge checks have vetoed the merge.</li>
     * </ul>
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getCanMerge(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Merge the specified pull request.
     * <p>
     * The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that
     * this pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $version        (optional) the current version of the pull request. If the server's version isn't
     *                                the same as the specified                 version the operation will fail. To
     *                                determine the current version of the pull request it should be
     *                                fetched from the server prior to this operation. Look for the 'version' attribute
     *                                in the returned                 JSON structure.
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createMerge(
        $projectKey,
        $repositorySlug,
        $version = -1,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/merge';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'version'        => (null != $version) ? $version : -1,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $pullRequestId  TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function get(
        $projectKey,
        $repositorySlug,
        $pullRequestId
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the title, description, reviewers or destination branch of an existing pull request.
     * <p>
     * <strong>Note:</strong> the <em>reviewers</em> list may be updated using this resource. However the
     * <em>author</em> and <em>participants</em> list may not.
     * <p>
     * The authenticated user must either:
     * <ul>
     * <li>be the author of the pull request and have the <strong>REPO_READ</strong> permission for
     * the repository
     * that this pull request targets; or</li>
     * <li>have the <strong>REPO_WRITE</strong> permission for the repository that this pull request
     * targets</li>
     * </ul>
     * to call this resource.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $pullRequestId  TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function update(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $pullRequestId
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Add a new comment.
     * <p>
     * Comments can be added in a few places by setting different attributes:
     * <p>
     * General commit comment:
     * 
     * <pre>
     * {
     * "text": "An insightful general comment on a commit."
     * }
     * </pre>
     * 
     * Reply to a comment:
     * 
     * <pre>
     * {
     * "text": "A measured reply.",
     * "parent": {
     * "id": 1
     * }
     * }
     * </pre>
     * 
     * General file comment:
     * 
     * <pre>
     * {
     * "text": "An insightful general comment on a file.",
     * "anchor": {
     * "path": "path/to/file",
     * "srcPath": "path/to/file"
     * }
     * }
     * </pre>
     * 
     * File line comment:
     * 
     * <pre>
     * {
     * "text": "A pithy comment on a particular line within a file.",
     * "anchor": {
     * "line": 1,
     * "lineType": "CONTEXT",
     * "fileType": "FROM"
     * "path": "path/to/file",
     * "srcPath": "path/to/file"
     * }
     * }
     * </pre>
     * <strong>Note: general file comments are an experimental feature and may change in the near future!
     * </strong>
     * <p>
     * For file and line comments, 'path' refers to the path of the file to which the comment should be
     * applied and
     * 'srcPath' refers to the path the that file used to have (only required for copies and moves).
     * <p>
     * For line comments, 'line' refers to the line in the diff that the comment should apply to.
     * 'lineType' refers to
     * the type of diff hunk, which can be:
     * <ul>
     * <li>'ADDED' - for an added line;</li>
     * <li>'REMOVED' - for a removed line; or</li>
     * <li>'CONTEXT' - for a line that was unmodified but is in the vicinity of the diff.</li>
     * </ul>
     * 'fileType' refers to the file of the diff to which the anchor should be attached - which is of
     * relevance when
     * displaying the diff in a side-by-side way. Currently the supported values are:
     * <ul>
     * <li>'FROM' - the source file of the diff</li>
     * <li>'TO' - the destination file of the diff</li>
     * </ul>
     * If the current user is not a participant the user is added as one and updated to watch the commit.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the
     * commit
     * is in to call this resource.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $since          (optional) TODO: type description here
     * @param string $commitId       (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createComment(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $since = null,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'since'          => $since,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * @todo Add general description for this endpoint
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $path           (optional) TODO: type description here
     * @param string $since          (optional) TODO: type description here
     * @param string $commitId       (optional) TODO: type description here
     * @return mixed response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getComments(
        $projectKey,
        $repositorySlug,
        $path = null,
        $since = null,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'path'           => $path,
            'since'          => $since,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Accept'        => 'application/json'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the text of a comment. Only the user who created a comment may update it.
     * <p>
     * <strong>Note:</strong> the supplied supplied JSON object must contain a <code>version</code> that
     * must match
     * the server's version of the comment or the update will fail. To determine the current version of
     * the comment,
     * the comment should be fetched from the server prior to the update. Look for the 'version' attribute
     * in the
     * returned JSON structure.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the
     * commit
     * is in to call this resource.
     *
     * @param object  $dynamic        TODO: type description here
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $commitId       (optional) the <i>full {@link Changeset#getId() ID}</i> of the commit within the
     *                                repository
     * @param integer $commentId      (optional) the ID of the comment to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateComment(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $commitId = null,
        $commentId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            'commentId'      => $commentId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Delete a commit comment. Anyone can delete their own comment. Only users with
     * <strong>REPO_ADMIN</strong>
     * and above may delete comments created by other users. Comments which have replies <i>may not be
     * deleted</i>,
     * regardless of the user's granted permissions.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the
     * commit
     * is in to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $version        (optional) The expected version of the comment. This must match the server's
     *                                version of the comment or                   the delete will fail. To determine
     *                                the current version of the comment, the comment should be
     *                                fetched from the server prior to the delete. Look for the 'version' attribute in
     *                                the returned                   JSON structure.
     * @param string  $commitId       (optional) the <i>full {@link Changeset#getId() ID}</i> of the commit within the
     *                                repository
     * @param integer $commentId      (optional) the ID of the comment to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteComment(
        $projectKey,
        $repositorySlug,
        $version = -1,
        $commitId = null,
        $commentId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            'commentId'      => $commentId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'version'        => (null != $version) ? $version : -1,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a commit discussion comment.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that the
     * commit
     * is in to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $commitId       (optional) the <i>full {@link Changeset#getId() ID}</i> of the commit within the
     *                                repository
     * @param integer $commentId      (optional) the ID of the comment to retrieve
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getComment(
        $projectKey,
        $repositorySlug,
        $commitId = null,
        $commentId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/comments/{commentId}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            'commentId'      => $commentId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Assigns a participant to an explicit role in pull request. Currently only the REVIEWER role may be
     * assigned.
     * <p>
     * If the user is not yet a participant in the pull request, they are made one and assigned the
     * supplied role.
     * <p>
     * If the user is already a participant in the pull request, their previous role is replaced with the
     * supplied role
     * unless they are already assigned the AUTHOR role which cannot be changed and will result in a Bad
     * Request (400)
     * response code.
     * <p>
     * The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that
     * this pull request
     * targets to call this resource.
     *
     * @param object  $dynamic        TODO: type description here
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createAssignParticipantRole(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Unassigns a participant from the REVIEWER role they may have been given in a pull request.
     * <p>
     * If the participant has no explicit role this method has no effect.
     * <p>
     * Afterwards, the user will still remain a participant in the pull request but their role will be
     * reduced to
     * PARTICIPANT. This is because once made a participant of a pull request,
     * a user will forever remain a participant. Only their role may be altered.
     * <p>
     * The authenticated user must have <strong>REPO_WRITE</strong> permission for the repository that
     * this pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param string  $username       (optional) the participant's user name
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteUnassignParticipantRole(
        $projectKey,
        $repositorySlug,
        $username = null,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'username'       => $username,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieves a page of the participants for a given pull request.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function listParticipants(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/participants';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a map of user setting key values for a specific user identified by the user slug.
     * <p>
     *
     * @param string $userSlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getUserSettings(
        $userSlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users/{userSlug}/settings';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'userSlug' => $userSlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Update the entries of a map of user setting key/values for a specific user identified by the user
     * slug.
     * <p>
     *
     * @param object $dynamic  TODO: type description here
     * @param string $userSlug TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSettings(
        $dynamic,
        $userSlug
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/users/{userSlug}/settings';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'userSlug' => $userSlug,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of repository hooks for this repository.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $type           (optional) the optional type to filter by. Valid values are
     *                               <code>PRE_RECEIVE</code> or <code>POST_RECEIVE</code>
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRepositoryHooks(
        $projectKey,
        $repositorySlug,
        $type = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'type'           => $type,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Modify the settings for a repository hook for this repositories.
     * <p>
     * The service will reject any settings which are too large, the current limit is 32KB once serialized.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param object $dynamic        TODO: type description here
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $hookKey        (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateSetSettings(
        $dynamic,
        $projectKey,
        $repositorySlug,
        $hookKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'hookKey'        => $hookKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'content-type'  => 'application/json; charset=utf-8'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers, Request\Body::Json($dynamic));

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the settings for a repository hook for this repositories.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $hookKey        (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getSettings(
        $projectKey,
        $repositorySlug,
        $hookKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/settings';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'hookKey'        => $hookKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a repository hook for this repositories.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $hookKey        (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getRepositoryHook(
        $projectKey,
        $repositorySlug,
        $hookKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'hookKey'        => $hookKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Enable a repository hook for this repositories and optionally applying new configuration.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $contentLength  (optional) Example: 0
     * @param string  $hookKey        (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function updateEnableHook(
        $projectKey,
        $repositorySlug,
        $contentLength = 0,
        $hookKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'hookKey'        => $hookKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0',
            'Content-Length'  => (null != $contentLength) ? $contentLength : 0
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::PUT, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::put($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Disable a repository hook for this repositories.
     * <p>
     * The authenticated user must have <strong>REPO_ADMIN</strong> permission for the specified
     * repository to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $hookKey        (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteDisableHook(
        $projectKey,
        $repositorySlug,
        $hookKey = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/settings/hooks/{hookKey}/enabled';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'hookKey'        => $hookKey,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve a page of changes made in a specified commit.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $since          (optional) the commit to which <code>until</code> should be compared to produce a
     *                               page of changes.                      If not specified the commit's first parent
     *                               is assumed (if one exists)
     * @param string $until          (optional) the commit to retrieve changes for
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getChanges(
        $projectKey,
        $repositorySlug,
        $since = null,
        $until = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/changes';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'since'          => $since,
            'until'          => $until,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Removes the authenticated user as a watcher for the specified commit.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository
     * containing the commit
     * to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $commitId       (optional) the <i>full {@link Changeset#getId() ID}</i> of the commit within the
     *                               repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteUnwatch(
        $projectKey,
        $repositorySlug,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Adds the authenticated user as a watcher for the specified commit.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository
     * containing the commit
     * to call this resource.
     *
     * @param string $projectKey     TODO: type description here
     * @param string $repositorySlug TODO: type description here
     * @param string $commitId       (optional) the <i>full {@link Changeset#getId() ID}</i> of the commit within the
     *                               repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createWatch(
        $projectKey,
        $repositorySlug,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/watch';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Approve a pull request as the current user. Implicitly adds the user as a participant if they are
     * not already.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function createApprove(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::POST, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::post($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Remove approval from a pull request as the current user. This does not remove the user as a
     * participant.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the repository that this
     * pull request
     * targets to call this resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $pullRequestId  (optional) the id of the pull request within the repository
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function deleteWithdrawApproval(
        $projectKey,
        $repositorySlug,
        $pullRequestId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/pull-requests/{pullRequestId}/approve';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'pullRequestId'  => $pullRequestId,
            ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::DELETE, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::delete($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the diff between two provided revisions.
     * <p>
     * <strong>Note:</strong> This resource is currently <i>not paged</i>. The server will internally
     * apply a hard cap
     * to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.
     * In the event
     * that the cap is reached, the diff will be cut short and one or more <code>truncated</code> flags
     * will be set to
     * <code>true</code> on the segments, hunks and diffs substructures in the returned JSON response.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $contextLines   (optional) the number of context lines to include around added/removed lines in
     *                                the diff
     * @param string  $since          (optional) the base revision to diff from. If omitted the parent revision of the
     *                                until revision is used
     * @param string  $srcPath        (optional) the source path for the file, if it was copied, moved or renamed
     * @param string  $whitespace     (optional) optional whitespace flag which can be set to <code>ignore-all</code>
     * @param bool    $withComments   (optional) <code>true</code> to embed comments in the diff (the default);
     *                                otherwise <code>false</code>                      to stream the diff without
     *                                comments
     * @param string  $commitId       (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $contextLines = -1,
        $since = null,
        $srcPath = null,
        $whitespace = null,
        $withComments = true,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'commitId'       => $commitId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'since'          => $since,
            'srcPath'        => $srcPath,
            'whitespace'     => $whitespace,
            'withComments'   => (null != $withComments) ? var_export($withComments, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }

    /**
     * Retrieve the diff between two provided revisions.
     * <p>
     * <strong>Note:</strong> This resource is currently <i>not paged</i>. The server will internally
     * apply a hard cap
     * to the streamed lines, and it is not possible to request subsequent pages if that cap is exceeded.
     * In the event
     * that the cap is reached, the diff will be cut short and one or more <code>truncated</code> flags
     * will be set to
     * <code>true</code> on the segments, hunks and diffs substructures in the returned JSON response.
     * <p>
     * The authenticated user must have <strong>REPO_READ</strong> permission for the specified repository
     * to call this
     * resource.
     *
     * @param string  $projectKey     TODO: type description here
     * @param string  $repositorySlug TODO: type description here
     * @param integer $contextLines   (optional) the number of context lines to include around added/removed lines in
     *                                the diff
     * @param string  $since          (optional) the base revision to diff from. If omitted the parent revision of the
     *                                until revision is used
     * @param string  $srcPath        (optional) the source path for the file, if it was copied, moved or renamed
     * @param string  $whitespace     (optional) optional whitespace flag which can be set to <code>ignore-all</code>
     * @param bool    $withComments   (optional) <code>true</code> to embed comments in the diff (the default);
     *                                otherwise <code>false</code>                      to stream the diff without
     *                                comments
     * @param string  $path           (optional) the path to the file which should be diffed (optional)
     * @param string  $commitId       (optional) TODO: type description here
     * @return string response from the API call
     * @throws APIException Thrown if API call fails
     */
    public function getStreamDiff(
        $projectKey,
        $repositorySlug,
        $contextLines = -1,
        $since = null,
        $srcPath = null,
        $whitespace = null,
        $withComments = true,
        $path = null,
        $commitId = null
    ) {

        //the base uri for api requests
        $_queryBuilder = Configuration::$BASEURI;
        
        //prepare query string for API call
        $_queryBuilder = $_queryBuilder.'/api/1.0/projects/{projectKey}/repos/{repositorySlug}/commits/{commitId}/diff/{path}';

        //process optional query parameters
        $_queryBuilder = APIHelper::appendUrlWithTemplateParameters($_queryBuilder, array (
            'projectKey'     => $projectKey,
            'repositorySlug' => $repositorySlug,
            'path'           => $path,
            'commitId'       => $commitId,
            ));

        //process optional query parameters
        APIHelper::appendUrlWithQueryParameters($_queryBuilder, array (
            'contextLines'   => (null != $contextLines) ? $contextLines : -1,
            'since'          => $since,
            'srcPath'        => $srcPath,
            'whitespace'     => $whitespace,
            'withComments'   => (null != $withComments) ? var_export($withComments, true) : true,
        ));

        //validate and preprocess url
        $_queryUrl = APIHelper::cleanUrl($_queryBuilder);

        //prepare headers
        $_headers = array (
            'user-agent'    => 'APIMATIC 2.0'
        );

        //call on-before Http callback
        $_httpRequest = new HttpRequest(HttpMethod::GET, $_headers, $_queryUrl);
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnBeforeRequest($_httpRequest);
        }

        //and invoke the API call request to fetch the response
        $response = Request::get($_queryUrl, $_headers);

        $_httpResponse = new HttpResponse($response->code, $response->headers, $response->raw_body);
        $_httpContext = new HttpContext($_httpRequest, $_httpResponse);

        //call on-after Http callback
        if ($this->getHttpCallBack() != null) {
            $this->getHttpCallBack()->callOnAfterRequest($_httpContext);
        }

        //handle errors defined at the API level
        $this->validateResponse($_httpResponse, $_httpContext);

        return $response->body;
    }
}
